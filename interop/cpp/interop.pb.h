// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interop.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_interop_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_interop_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_interop_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_interop_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_interop_2eproto;
namespace pb {
class ConnManagerRequest;
struct ConnManagerRequestDefaultTypeInternal;
extern ConnManagerRequestDefaultTypeInternal _ConnManagerRequest_default_instance_;
class ConnectRequest;
struct ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class DHTRequest;
struct DHTRequestDefaultTypeInternal;
extern DHTRequestDefaultTypeInternal _DHTRequest_default_instance_;
class DHTResponse;
struct DHTResponseDefaultTypeInternal;
extern DHTResponseDefaultTypeInternal _DHTResponse_default_instance_;
class DisconnectRequest;
struct DisconnectRequestDefaultTypeInternal;
extern DisconnectRequestDefaultTypeInternal _DisconnectRequest_default_instance_;
class ErrorResponse;
struct ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class IdentifyResponse;
struct IdentifyResponseDefaultTypeInternal;
extern IdentifyResponseDefaultTypeInternal _IdentifyResponse_default_instance_;
class PSMessage;
struct PSMessageDefaultTypeInternal;
extern PSMessageDefaultTypeInternal _PSMessage_default_instance_;
class PSRequest;
struct PSRequestDefaultTypeInternal;
extern PSRequestDefaultTypeInternal _PSRequest_default_instance_;
class PSResponse;
struct PSResponseDefaultTypeInternal;
extern PSResponseDefaultTypeInternal _PSResponse_default_instance_;
class PeerInfo;
struct PeerInfoDefaultTypeInternal;
extern PeerInfoDefaultTypeInternal _PeerInfo_default_instance_;
class PeerstoreRequest;
struct PeerstoreRequestDefaultTypeInternal;
extern PeerstoreRequestDefaultTypeInternal _PeerstoreRequest_default_instance_;
class PeerstoreResponse;
struct PeerstoreResponseDefaultTypeInternal;
extern PeerstoreResponseDefaultTypeInternal _PeerstoreResponse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class StreamHandlerRequest;
struct StreamHandlerRequestDefaultTypeInternal;
extern StreamHandlerRequestDefaultTypeInternal _StreamHandlerRequest_default_instance_;
class StreamInfo;
struct StreamInfoDefaultTypeInternal;
extern StreamInfoDefaultTypeInternal _StreamInfo_default_instance_;
class StreamOpenRequest;
struct StreamOpenRequestDefaultTypeInternal;
extern StreamOpenRequestDefaultTypeInternal _StreamOpenRequest_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::ConnManagerRequest* Arena::CreateMaybeMessage<::pb::ConnManagerRequest>(Arena*);
template<> ::pb::ConnectRequest* Arena::CreateMaybeMessage<::pb::ConnectRequest>(Arena*);
template<> ::pb::DHTRequest* Arena::CreateMaybeMessage<::pb::DHTRequest>(Arena*);
template<> ::pb::DHTResponse* Arena::CreateMaybeMessage<::pb::DHTResponse>(Arena*);
template<> ::pb::DisconnectRequest* Arena::CreateMaybeMessage<::pb::DisconnectRequest>(Arena*);
template<> ::pb::ErrorResponse* Arena::CreateMaybeMessage<::pb::ErrorResponse>(Arena*);
template<> ::pb::IdentifyResponse* Arena::CreateMaybeMessage<::pb::IdentifyResponse>(Arena*);
template<> ::pb::PSMessage* Arena::CreateMaybeMessage<::pb::PSMessage>(Arena*);
template<> ::pb::PSRequest* Arena::CreateMaybeMessage<::pb::PSRequest>(Arena*);
template<> ::pb::PSResponse* Arena::CreateMaybeMessage<::pb::PSResponse>(Arena*);
template<> ::pb::PeerInfo* Arena::CreateMaybeMessage<::pb::PeerInfo>(Arena*);
template<> ::pb::PeerstoreRequest* Arena::CreateMaybeMessage<::pb::PeerstoreRequest>(Arena*);
template<> ::pb::PeerstoreResponse* Arena::CreateMaybeMessage<::pb::PeerstoreResponse>(Arena*);
template<> ::pb::Request* Arena::CreateMaybeMessage<::pb::Request>(Arena*);
template<> ::pb::Response* Arena::CreateMaybeMessage<::pb::Response>(Arena*);
template<> ::pb::StreamHandlerRequest* Arena::CreateMaybeMessage<::pb::StreamHandlerRequest>(Arena*);
template<> ::pb::StreamInfo* Arena::CreateMaybeMessage<::pb::StreamInfo>(Arena*);
template<> ::pb::StreamOpenRequest* Arena::CreateMaybeMessage<::pb::StreamOpenRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum Request_Type : int {
  Request_Type_IDENTIFY = 0,
  Request_Type_CONNECT = 1,
  Request_Type_STREAM_OPEN = 2,
  Request_Type_STREAM_HANDLER = 3,
  Request_Type_DHT = 4,
  Request_Type_LIST_PEERS = 5,
  Request_Type_CONNMANAGER = 6,
  Request_Type_DISCONNECT = 7,
  Request_Type_PUBSUB = 8,
  Request_Type_PEERSTORE = 9,
  Request_Type_Request_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Request_Type_Request_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Request_Type_IsValid(int value);
constexpr Request_Type Request_Type_Type_MIN = Request_Type_IDENTIFY;
constexpr Request_Type Request_Type_Type_MAX = Request_Type_PEERSTORE;
constexpr int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_Type_descriptor();
template<typename T>
inline const std::string& Request_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_Type_descriptor(), enum_t_value);
}
inline bool Request_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Response_Type : int {
  Response_Type_OK = 0,
  Response_Type_ERROR = 1,
  Response_Type_Response_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Response_Type_Response_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Response_Type_IsValid(int value);
constexpr Response_Type Response_Type_Type_MIN = Response_Type_OK;
constexpr Response_Type Response_Type_Type_MAX = Response_Type_ERROR;
constexpr int Response_Type_Type_ARRAYSIZE = Response_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_Type_descriptor();
template<typename T>
inline const std::string& Response_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Response_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Response_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Response_Type_descriptor(), enum_t_value);
}
inline bool Response_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Response_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Response_Type>(
    Response_Type_descriptor(), name, value);
}
enum DHTRequest_Type : int {
  DHTRequest_Type_FIND_PEER = 0,
  DHTRequest_Type_FIND_PEERS_CONNECTED_TO_PEER = 1,
  DHTRequest_Type_FIND_PROVIDERS = 2,
  DHTRequest_Type_GET_CLOSEST_PEERS = 3,
  DHTRequest_Type_GET_PUBLIC_KEY = 4,
  DHTRequest_Type_GET_VALUE = 5,
  DHTRequest_Type_SEARCH_VALUE = 6,
  DHTRequest_Type_PUT_VALUE = 7,
  DHTRequest_Type_PROVIDE = 8,
  DHTRequest_Type_DHTRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DHTRequest_Type_DHTRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DHTRequest_Type_IsValid(int value);
constexpr DHTRequest_Type DHTRequest_Type_Type_MIN = DHTRequest_Type_FIND_PEER;
constexpr DHTRequest_Type DHTRequest_Type_Type_MAX = DHTRequest_Type_PROVIDE;
constexpr int DHTRequest_Type_Type_ARRAYSIZE = DHTRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DHTRequest_Type_descriptor();
template<typename T>
inline const std::string& DHTRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DHTRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DHTRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DHTRequest_Type_descriptor(), enum_t_value);
}
inline bool DHTRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DHTRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DHTRequest_Type>(
    DHTRequest_Type_descriptor(), name, value);
}
enum DHTResponse_Type : int {
  DHTResponse_Type_BEGIN = 0,
  DHTResponse_Type_VALUE = 1,
  DHTResponse_Type_END = 2,
  DHTResponse_Type_DHTResponse_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DHTResponse_Type_DHTResponse_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DHTResponse_Type_IsValid(int value);
constexpr DHTResponse_Type DHTResponse_Type_Type_MIN = DHTResponse_Type_BEGIN;
constexpr DHTResponse_Type DHTResponse_Type_Type_MAX = DHTResponse_Type_END;
constexpr int DHTResponse_Type_Type_ARRAYSIZE = DHTResponse_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DHTResponse_Type_descriptor();
template<typename T>
inline const std::string& DHTResponse_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DHTResponse_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DHTResponse_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DHTResponse_Type_descriptor(), enum_t_value);
}
inline bool DHTResponse_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DHTResponse_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DHTResponse_Type>(
    DHTResponse_Type_descriptor(), name, value);
}
enum ConnManagerRequest_Type : int {
  ConnManagerRequest_Type_TAG_PEER = 0,
  ConnManagerRequest_Type_UNTAG_PEER = 1,
  ConnManagerRequest_Type_TRIM = 2,
  ConnManagerRequest_Type_ConnManagerRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnManagerRequest_Type_ConnManagerRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnManagerRequest_Type_IsValid(int value);
constexpr ConnManagerRequest_Type ConnManagerRequest_Type_Type_MIN = ConnManagerRequest_Type_TAG_PEER;
constexpr ConnManagerRequest_Type ConnManagerRequest_Type_Type_MAX = ConnManagerRequest_Type_TRIM;
constexpr int ConnManagerRequest_Type_Type_ARRAYSIZE = ConnManagerRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnManagerRequest_Type_descriptor();
template<typename T>
inline const std::string& ConnManagerRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnManagerRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnManagerRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnManagerRequest_Type_descriptor(), enum_t_value);
}
inline bool ConnManagerRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnManagerRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnManagerRequest_Type>(
    ConnManagerRequest_Type_descriptor(), name, value);
}
enum PSRequest_Type : int {
  PSRequest_Type_GET_TOPICS = 0,
  PSRequest_Type_LIST_PEERS = 1,
  PSRequest_Type_PUBLISH = 2,
  PSRequest_Type_SUBSCRIBE = 3,
  PSRequest_Type_PSRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PSRequest_Type_PSRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PSRequest_Type_IsValid(int value);
constexpr PSRequest_Type PSRequest_Type_Type_MIN = PSRequest_Type_GET_TOPICS;
constexpr PSRequest_Type PSRequest_Type_Type_MAX = PSRequest_Type_SUBSCRIBE;
constexpr int PSRequest_Type_Type_ARRAYSIZE = PSRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PSRequest_Type_descriptor();
template<typename T>
inline const std::string& PSRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PSRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PSRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PSRequest_Type_descriptor(), enum_t_value);
}
inline bool PSRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PSRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PSRequest_Type>(
    PSRequest_Type_descriptor(), name, value);
}
enum PeerstoreRequest_Type : int {
  PeerstoreRequest_Type_UNSPECIFIED = 0,
  PeerstoreRequest_Type_GET_PROTOCOLS = 1,
  PeerstoreRequest_Type_GET_PEER_INFO = 2,
  PeerstoreRequest_Type_PeerstoreRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerstoreRequest_Type_PeerstoreRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerstoreRequest_Type_IsValid(int value);
constexpr PeerstoreRequest_Type PeerstoreRequest_Type_Type_MIN = PeerstoreRequest_Type_UNSPECIFIED;
constexpr PeerstoreRequest_Type PeerstoreRequest_Type_Type_MAX = PeerstoreRequest_Type_GET_PEER_INFO;
constexpr int PeerstoreRequest_Type_Type_ARRAYSIZE = PeerstoreRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerstoreRequest_Type_descriptor();
template<typename T>
inline const std::string& PeerstoreRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerstoreRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerstoreRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerstoreRequest_Type_descriptor(), enum_t_value);
}
inline bool PeerstoreRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerstoreRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerstoreRequest_Type>(
    PeerstoreRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static constexpr Type IDENTIFY =
    Request_Type_IDENTIFY;
  static constexpr Type CONNECT =
    Request_Type_CONNECT;
  static constexpr Type STREAM_OPEN =
    Request_Type_STREAM_OPEN;
  static constexpr Type STREAM_HANDLER =
    Request_Type_STREAM_HANDLER;
  static constexpr Type DHT =
    Request_Type_DHT;
  static constexpr Type LIST_PEERS =
    Request_Type_LIST_PEERS;
  static constexpr Type CONNMANAGER =
    Request_Type_CONNMANAGER;
  static constexpr Type DISCONNECT =
    Request_Type_DISCONNECT;
  static constexpr Type PUBSUB =
    Request_Type_PUBSUB;
  static constexpr Type PEERSTORE =
    Request_Type_PEERSTORE;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Request_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Request_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Request_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectFieldNumber = 2,
    kStreamOpenFieldNumber = 3,
    kStreamHandlerFieldNumber = 4,
    kDhtFieldNumber = 5,
    kConnManagerFieldNumber = 6,
    kDisconnectFieldNumber = 7,
    kPubsubFieldNumber = 8,
    kPeerStoreFieldNumber = 9,
    kTypeFieldNumber = 1,
  };
  // optional .pb.ConnectRequest connect = 2;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::pb::ConnectRequest& connect() const;
  PROTOBUF_NODISCARD ::pb::ConnectRequest* release_connect();
  ::pb::ConnectRequest* mutable_connect();
  void set_allocated_connect(::pb::ConnectRequest* connect);
  private:
  const ::pb::ConnectRequest& _internal_connect() const;
  ::pb::ConnectRequest* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::pb::ConnectRequest* connect);
  ::pb::ConnectRequest* unsafe_arena_release_connect();

  // optional .pb.StreamOpenRequest streamOpen = 3;
  bool has_streamopen() const;
  private:
  bool _internal_has_streamopen() const;
  public:
  void clear_streamopen();
  const ::pb::StreamOpenRequest& streamopen() const;
  PROTOBUF_NODISCARD ::pb::StreamOpenRequest* release_streamopen();
  ::pb::StreamOpenRequest* mutable_streamopen();
  void set_allocated_streamopen(::pb::StreamOpenRequest* streamopen);
  private:
  const ::pb::StreamOpenRequest& _internal_streamopen() const;
  ::pb::StreamOpenRequest* _internal_mutable_streamopen();
  public:
  void unsafe_arena_set_allocated_streamopen(
      ::pb::StreamOpenRequest* streamopen);
  ::pb::StreamOpenRequest* unsafe_arena_release_streamopen();

  // optional .pb.StreamHandlerRequest streamHandler = 4;
  bool has_streamhandler() const;
  private:
  bool _internal_has_streamhandler() const;
  public:
  void clear_streamhandler();
  const ::pb::StreamHandlerRequest& streamhandler() const;
  PROTOBUF_NODISCARD ::pb::StreamHandlerRequest* release_streamhandler();
  ::pb::StreamHandlerRequest* mutable_streamhandler();
  void set_allocated_streamhandler(::pb::StreamHandlerRequest* streamhandler);
  private:
  const ::pb::StreamHandlerRequest& _internal_streamhandler() const;
  ::pb::StreamHandlerRequest* _internal_mutable_streamhandler();
  public:
  void unsafe_arena_set_allocated_streamhandler(
      ::pb::StreamHandlerRequest* streamhandler);
  ::pb::StreamHandlerRequest* unsafe_arena_release_streamhandler();

  // optional .pb.DHTRequest dht = 5;
  bool has_dht() const;
  private:
  bool _internal_has_dht() const;
  public:
  void clear_dht();
  const ::pb::DHTRequest& dht() const;
  PROTOBUF_NODISCARD ::pb::DHTRequest* release_dht();
  ::pb::DHTRequest* mutable_dht();
  void set_allocated_dht(::pb::DHTRequest* dht);
  private:
  const ::pb::DHTRequest& _internal_dht() const;
  ::pb::DHTRequest* _internal_mutable_dht();
  public:
  void unsafe_arena_set_allocated_dht(
      ::pb::DHTRequest* dht);
  ::pb::DHTRequest* unsafe_arena_release_dht();

  // optional .pb.ConnManagerRequest connManager = 6;
  bool has_connmanager() const;
  private:
  bool _internal_has_connmanager() const;
  public:
  void clear_connmanager();
  const ::pb::ConnManagerRequest& connmanager() const;
  PROTOBUF_NODISCARD ::pb::ConnManagerRequest* release_connmanager();
  ::pb::ConnManagerRequest* mutable_connmanager();
  void set_allocated_connmanager(::pb::ConnManagerRequest* connmanager);
  private:
  const ::pb::ConnManagerRequest& _internal_connmanager() const;
  ::pb::ConnManagerRequest* _internal_mutable_connmanager();
  public:
  void unsafe_arena_set_allocated_connmanager(
      ::pb::ConnManagerRequest* connmanager);
  ::pb::ConnManagerRequest* unsafe_arena_release_connmanager();

  // optional .pb.DisconnectRequest disconnect = 7;
  bool has_disconnect() const;
  private:
  bool _internal_has_disconnect() const;
  public:
  void clear_disconnect();
  const ::pb::DisconnectRequest& disconnect() const;
  PROTOBUF_NODISCARD ::pb::DisconnectRequest* release_disconnect();
  ::pb::DisconnectRequest* mutable_disconnect();
  void set_allocated_disconnect(::pb::DisconnectRequest* disconnect);
  private:
  const ::pb::DisconnectRequest& _internal_disconnect() const;
  ::pb::DisconnectRequest* _internal_mutable_disconnect();
  public:
  void unsafe_arena_set_allocated_disconnect(
      ::pb::DisconnectRequest* disconnect);
  ::pb::DisconnectRequest* unsafe_arena_release_disconnect();

  // optional .pb.PSRequest pubsub = 8;
  bool has_pubsub() const;
  private:
  bool _internal_has_pubsub() const;
  public:
  void clear_pubsub();
  const ::pb::PSRequest& pubsub() const;
  PROTOBUF_NODISCARD ::pb::PSRequest* release_pubsub();
  ::pb::PSRequest* mutable_pubsub();
  void set_allocated_pubsub(::pb::PSRequest* pubsub);
  private:
  const ::pb::PSRequest& _internal_pubsub() const;
  ::pb::PSRequest* _internal_mutable_pubsub();
  public:
  void unsafe_arena_set_allocated_pubsub(
      ::pb::PSRequest* pubsub);
  ::pb::PSRequest* unsafe_arena_release_pubsub();

  // optional .pb.PeerstoreRequest peerStore = 9;
  bool has_peerstore() const;
  private:
  bool _internal_has_peerstore() const;
  public:
  void clear_peerstore();
  const ::pb::PeerstoreRequest& peerstore() const;
  PROTOBUF_NODISCARD ::pb::PeerstoreRequest* release_peerstore();
  ::pb::PeerstoreRequest* mutable_peerstore();
  void set_allocated_peerstore(::pb::PeerstoreRequest* peerstore);
  private:
  const ::pb::PeerstoreRequest& _internal_peerstore() const;
  ::pb::PeerstoreRequest* _internal_mutable_peerstore();
  public:
  void unsafe_arena_set_allocated_peerstore(
      ::pb::PeerstoreRequest* peerstore);
  ::pb::PeerstoreRequest* unsafe_arena_release_peerstore();

  // optional .pb.Request.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::Request_Type type() const;
  void set_type(::pb::Request_Type value);
  private:
  ::pb::Request_Type _internal_type() const;
  void _internal_set_type(::pb::Request_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::ConnectRequest* connect_;
  ::pb::StreamOpenRequest* streamopen_;
  ::pb::StreamHandlerRequest* streamhandler_;
  ::pb::DHTRequest* dht_;
  ::pb::ConnManagerRequest* connmanager_;
  ::pb::DisconnectRequest* disconnect_;
  ::pb::PSRequest* pubsub_;
  ::pb::PeerstoreRequest* peerstore_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Response_Type Type;
  static constexpr Type OK =
    Response_Type_OK;
  static constexpr Type ERROR =
    Response_Type_ERROR;
  static inline bool Type_IsValid(int value) {
    return Response_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Response_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Response_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Response_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Response_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Response_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Response_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 6,
    kErrorFieldNumber = 2,
    kStreamInfoFieldNumber = 3,
    kIdentifyFieldNumber = 4,
    kDhtFieldNumber = 5,
    kPubsubFieldNumber = 7,
    kPeerStoreFieldNumber = 8,
    kTypeFieldNumber = 1,
  };
  // repeated .pb.PeerInfo peers = 6;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::pb::PeerInfo* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PeerInfo >*
      mutable_peers();
  private:
  const ::pb::PeerInfo& _internal_peers(int index) const;
  ::pb::PeerInfo* _internal_add_peers();
  public:
  const ::pb::PeerInfo& peers(int index) const;
  ::pb::PeerInfo* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PeerInfo >&
      peers() const;

  // optional .pb.ErrorResponse error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::pb::ErrorResponse& error() const;
  PROTOBUF_NODISCARD ::pb::ErrorResponse* release_error();
  ::pb::ErrorResponse* mutable_error();
  void set_allocated_error(::pb::ErrorResponse* error);
  private:
  const ::pb::ErrorResponse& _internal_error() const;
  ::pb::ErrorResponse* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::pb::ErrorResponse* error);
  ::pb::ErrorResponse* unsafe_arena_release_error();

  // optional .pb.StreamInfo streamInfo = 3;
  bool has_streaminfo() const;
  private:
  bool _internal_has_streaminfo() const;
  public:
  void clear_streaminfo();
  const ::pb::StreamInfo& streaminfo() const;
  PROTOBUF_NODISCARD ::pb::StreamInfo* release_streaminfo();
  ::pb::StreamInfo* mutable_streaminfo();
  void set_allocated_streaminfo(::pb::StreamInfo* streaminfo);
  private:
  const ::pb::StreamInfo& _internal_streaminfo() const;
  ::pb::StreamInfo* _internal_mutable_streaminfo();
  public:
  void unsafe_arena_set_allocated_streaminfo(
      ::pb::StreamInfo* streaminfo);
  ::pb::StreamInfo* unsafe_arena_release_streaminfo();

  // optional .pb.IdentifyResponse identify = 4;
  bool has_identify() const;
  private:
  bool _internal_has_identify() const;
  public:
  void clear_identify();
  const ::pb::IdentifyResponse& identify() const;
  PROTOBUF_NODISCARD ::pb::IdentifyResponse* release_identify();
  ::pb::IdentifyResponse* mutable_identify();
  void set_allocated_identify(::pb::IdentifyResponse* identify);
  private:
  const ::pb::IdentifyResponse& _internal_identify() const;
  ::pb::IdentifyResponse* _internal_mutable_identify();
  public:
  void unsafe_arena_set_allocated_identify(
      ::pb::IdentifyResponse* identify);
  ::pb::IdentifyResponse* unsafe_arena_release_identify();

  // optional .pb.DHTResponse dht = 5;
  bool has_dht() const;
  private:
  bool _internal_has_dht() const;
  public:
  void clear_dht();
  const ::pb::DHTResponse& dht() const;
  PROTOBUF_NODISCARD ::pb::DHTResponse* release_dht();
  ::pb::DHTResponse* mutable_dht();
  void set_allocated_dht(::pb::DHTResponse* dht);
  private:
  const ::pb::DHTResponse& _internal_dht() const;
  ::pb::DHTResponse* _internal_mutable_dht();
  public:
  void unsafe_arena_set_allocated_dht(
      ::pb::DHTResponse* dht);
  ::pb::DHTResponse* unsafe_arena_release_dht();

  // optional .pb.PSResponse pubsub = 7;
  bool has_pubsub() const;
  private:
  bool _internal_has_pubsub() const;
  public:
  void clear_pubsub();
  const ::pb::PSResponse& pubsub() const;
  PROTOBUF_NODISCARD ::pb::PSResponse* release_pubsub();
  ::pb::PSResponse* mutable_pubsub();
  void set_allocated_pubsub(::pb::PSResponse* pubsub);
  private:
  const ::pb::PSResponse& _internal_pubsub() const;
  ::pb::PSResponse* _internal_mutable_pubsub();
  public:
  void unsafe_arena_set_allocated_pubsub(
      ::pb::PSResponse* pubsub);
  ::pb::PSResponse* unsafe_arena_release_pubsub();

  // optional .pb.PeerstoreResponse peerStore = 8;
  bool has_peerstore() const;
  private:
  bool _internal_has_peerstore() const;
  public:
  void clear_peerstore();
  const ::pb::PeerstoreResponse& peerstore() const;
  PROTOBUF_NODISCARD ::pb::PeerstoreResponse* release_peerstore();
  ::pb::PeerstoreResponse* mutable_peerstore();
  void set_allocated_peerstore(::pb::PeerstoreResponse* peerstore);
  private:
  const ::pb::PeerstoreResponse& _internal_peerstore() const;
  ::pb::PeerstoreResponse* _internal_mutable_peerstore();
  public:
  void unsafe_arena_set_allocated_peerstore(
      ::pb::PeerstoreResponse* peerstore);
  ::pb::PeerstoreResponse* unsafe_arena_release_peerstore();

  // optional .pb.Response.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::Response_Type type() const;
  void set_type(::pb::Response_Type value);
  private:
  ::pb::Response_Type _internal_type() const;
  void _internal_set_type(::pb::Response_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PeerInfo > peers_;
  ::pb::ErrorResponse* error_;
  ::pb::StreamInfo* streaminfo_;
  ::pb::IdentifyResponse* identify_;
  ::pb::DHTResponse* dht_;
  ::pb::PSResponse* pubsub_;
  ::pb::PeerstoreResponse* peerstore_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class IdentifyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.IdentifyResponse) */ {
 public:
  inline IdentifyResponse() : IdentifyResponse(nullptr) {}
  ~IdentifyResponse() override;
  explicit constexpr IdentifyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdentifyResponse(const IdentifyResponse& from);
  IdentifyResponse(IdentifyResponse&& from) noexcept
    : IdentifyResponse() {
    *this = ::std::move(from);
  }

  inline IdentifyResponse& operator=(const IdentifyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdentifyResponse& operator=(IdentifyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdentifyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdentifyResponse* internal_default_instance() {
    return reinterpret_cast<const IdentifyResponse*>(
               &_IdentifyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IdentifyResponse& a, IdentifyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IdentifyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdentifyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdentifyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdentifyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdentifyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IdentifyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdentifyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.IdentifyResponse";
  }
  protected:
  explicit IdentifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated bytes addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const void* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:pb.IdentifyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class ConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ConnectRequest) */ {
 public:
  inline ConnectRequest() : ConnectRequest(nullptr) {}
  ~ConnectRequest() override;
  explicit constexpr ConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectRequest(const ConnectRequest& from);
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ConnectRequest";
  }
  protected:
  explicit ConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 2,
    kPeerFieldNumber = 1,
    kTimeoutFieldNumber = 3,
  };
  // repeated bytes addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const void* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // bytes peer = 1;
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // optional int64 timeout = 3;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  int64_t timeout() const;
  void set_timeout(int64_t value);
  private:
  int64_t _internal_timeout() const;
  void _internal_set_timeout(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  int64_t timeout_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class StreamOpenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.StreamOpenRequest) */ {
 public:
  inline StreamOpenRequest() : StreamOpenRequest(nullptr) {}
  ~StreamOpenRequest() override;
  explicit constexpr StreamOpenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOpenRequest(const StreamOpenRequest& from);
  StreamOpenRequest(StreamOpenRequest&& from) noexcept
    : StreamOpenRequest() {
    *this = ::std::move(from);
  }

  inline StreamOpenRequest& operator=(const StreamOpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOpenRequest& operator=(StreamOpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOpenRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOpenRequest*>(
               &_StreamOpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamOpenRequest& a, StreamOpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOpenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOpenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamOpenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOpenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.StreamOpenRequest";
  }
  protected:
  explicit StreamOpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtoFieldNumber = 2,
    kPeerFieldNumber = 1,
    kTimeoutFieldNumber = 3,
  };
  // repeated string proto = 2;
  int proto_size() const;
  private:
  int _internal_proto_size() const;
  public:
  void clear_proto();
  const std::string& proto(int index) const;
  std::string* mutable_proto(int index);
  void set_proto(int index, const std::string& value);
  void set_proto(int index, std::string&& value);
  void set_proto(int index, const char* value);
  void set_proto(int index, const char* value, size_t size);
  std::string* add_proto();
  void add_proto(const std::string& value);
  void add_proto(std::string&& value);
  void add_proto(const char* value);
  void add_proto(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proto() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proto();
  private:
  const std::string& _internal_proto(int index) const;
  std::string* _internal_add_proto();
  public:

  // bytes peer = 1;
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // optional int64 timeout = 3;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  int64_t timeout() const;
  void set_timeout(int64_t value);
  private:
  int64_t _internal_timeout() const;
  void _internal_set_timeout(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.StreamOpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  int64_t timeout_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class StreamHandlerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.StreamHandlerRequest) */ {
 public:
  inline StreamHandlerRequest() : StreamHandlerRequest(nullptr) {}
  ~StreamHandlerRequest() override;
  explicit constexpr StreamHandlerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamHandlerRequest(const StreamHandlerRequest& from);
  StreamHandlerRequest(StreamHandlerRequest&& from) noexcept
    : StreamHandlerRequest() {
    *this = ::std::move(from);
  }

  inline StreamHandlerRequest& operator=(const StreamHandlerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamHandlerRequest& operator=(StreamHandlerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamHandlerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamHandlerRequest* internal_default_instance() {
    return reinterpret_cast<const StreamHandlerRequest*>(
               &_StreamHandlerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamHandlerRequest& a, StreamHandlerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamHandlerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamHandlerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamHandlerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamHandlerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamHandlerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamHandlerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamHandlerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.StreamHandlerRequest";
  }
  protected:
  explicit StreamHandlerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtoFieldNumber = 2,
    kAddrFieldNumber = 1,
  };
  // repeated string proto = 2;
  int proto_size() const;
  private:
  int _internal_proto_size() const;
  public:
  void clear_proto();
  const std::string& proto(int index) const;
  std::string* mutable_proto(int index);
  void set_proto(int index, const std::string& value);
  void set_proto(int index, std::string&& value);
  void set_proto(int index, const char* value);
  void set_proto(int index, const char* value, size_t size);
  std::string* add_proto();
  void add_proto(const std::string& value);
  void add_proto(std::string&& value);
  void add_proto(const char* value);
  void add_proto(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proto() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proto();
  private:
  const std::string& _internal_proto(int index) const;
  std::string* _internal_add_proto();
  public:

  // bytes addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:pb.StreamHandlerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class ErrorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {}
  ~ErrorResponse() override;
  explicit constexpr ErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorResponse(const ErrorResponse& from);
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ErrorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:pb.ErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class StreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.StreamInfo) */ {
 public:
  inline StreamInfo() : StreamInfo(nullptr) {}
  ~StreamInfo() override;
  explicit constexpr StreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInfo(const StreamInfo& from);
  StreamInfo(StreamInfo&& from) noexcept
    : StreamInfo() {
    *this = ::std::move(from);
  }

  inline StreamInfo& operator=(const StreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfo& operator=(StreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInfo* internal_default_instance() {
    return reinterpret_cast<const StreamInfo*>(
               &_StreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamInfo& a, StreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.StreamInfo";
  }
  protected:
  explicit StreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kAddrFieldNumber = 2,
    kProtoFieldNumber = 3,
  };
  // bytes peer = 1;
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // bytes addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string proto = 3;
  void clear_proto();
  const std::string& proto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proto();
  PROTOBUF_NODISCARD std::string* release_proto();
  void set_allocated_proto(std::string* proto);
  private:
  const std::string& _internal_proto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proto(const std::string& value);
  std::string* _internal_mutable_proto();
  public:

  // @@protoc_insertion_point(class_scope:pb.StreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class DHTRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.DHTRequest) */ {
 public:
  inline DHTRequest() : DHTRequest(nullptr) {}
  ~DHTRequest() override;
  explicit constexpr DHTRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DHTRequest(const DHTRequest& from);
  DHTRequest(DHTRequest&& from) noexcept
    : DHTRequest() {
    *this = ::std::move(from);
  }

  inline DHTRequest& operator=(const DHTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DHTRequest& operator=(DHTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DHTRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DHTRequest* internal_default_instance() {
    return reinterpret_cast<const DHTRequest*>(
               &_DHTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DHTRequest& a, DHTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DHTRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DHTRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DHTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DHTRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DHTRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DHTRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DHTRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.DHTRequest";
  }
  protected:
  explicit DHTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DHTRequest_Type Type;
  static constexpr Type FIND_PEER =
    DHTRequest_Type_FIND_PEER;
  static constexpr Type FIND_PEERS_CONNECTED_TO_PEER =
    DHTRequest_Type_FIND_PEERS_CONNECTED_TO_PEER;
  static constexpr Type FIND_PROVIDERS =
    DHTRequest_Type_FIND_PROVIDERS;
  static constexpr Type GET_CLOSEST_PEERS =
    DHTRequest_Type_GET_CLOSEST_PEERS;
  static constexpr Type GET_PUBLIC_KEY =
    DHTRequest_Type_GET_PUBLIC_KEY;
  static constexpr Type GET_VALUE =
    DHTRequest_Type_GET_VALUE;
  static constexpr Type SEARCH_VALUE =
    DHTRequest_Type_SEARCH_VALUE;
  static constexpr Type PUT_VALUE =
    DHTRequest_Type_PUT_VALUE;
  static constexpr Type PROVIDE =
    DHTRequest_Type_PROVIDE;
  static inline bool Type_IsValid(int value) {
    return DHTRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DHTRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DHTRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DHTRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return DHTRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DHTRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DHTRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 2,
    kCidFieldNumber = 3,
    kKeyFieldNumber = 4,
    kValueFieldNumber = 5,
    kTypeFieldNumber = 1,
    kCountFieldNumber = 6,
    kTimeoutFieldNumber = 7,
  };
  // optional bytes peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // optional bytes cid = 3;
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // optional bytes key = 4;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes value = 5;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .pb.DHTRequest.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::DHTRequest_Type type() const;
  void set_type(::pb::DHTRequest_Type value);
  private:
  ::pb::DHTRequest_Type _internal_type() const;
  void _internal_set_type(::pb::DHTRequest_Type value);
  public:

  // optional int32 count = 6;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // optional int64 timeout = 7;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  int64_t timeout() const;
  void set_timeout(int64_t value);
  private:
  int64_t _internal_timeout() const;
  void _internal_set_timeout(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.DHTRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int type_;
  int32_t count_;
  int64_t timeout_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class DHTResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.DHTResponse) */ {
 public:
  inline DHTResponse() : DHTResponse(nullptr) {}
  ~DHTResponse() override;
  explicit constexpr DHTResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DHTResponse(const DHTResponse& from);
  DHTResponse(DHTResponse&& from) noexcept
    : DHTResponse() {
    *this = ::std::move(from);
  }

  inline DHTResponse& operator=(const DHTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DHTResponse& operator=(DHTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DHTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DHTResponse* internal_default_instance() {
    return reinterpret_cast<const DHTResponse*>(
               &_DHTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DHTResponse& a, DHTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DHTResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DHTResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DHTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DHTResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DHTResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DHTResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DHTResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.DHTResponse";
  }
  protected:
  explicit DHTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DHTResponse_Type Type;
  static constexpr Type BEGIN =
    DHTResponse_Type_BEGIN;
  static constexpr Type VALUE =
    DHTResponse_Type_VALUE;
  static constexpr Type END =
    DHTResponse_Type_END;
  static inline bool Type_IsValid(int value) {
    return DHTResponse_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DHTResponse_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DHTResponse_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DHTResponse_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return DHTResponse_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DHTResponse_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DHTResponse_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kPeerFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional bytes value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .pb.PeerInfo peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::pb::PeerInfo& peer() const;
  PROTOBUF_NODISCARD ::pb::PeerInfo* release_peer();
  ::pb::PeerInfo* mutable_peer();
  void set_allocated_peer(::pb::PeerInfo* peer);
  private:
  const ::pb::PeerInfo& _internal_peer() const;
  ::pb::PeerInfo* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::pb::PeerInfo* peer);
  ::pb::PeerInfo* unsafe_arena_release_peer();

  // optional .pb.DHTResponse.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::DHTResponse_Type type() const;
  void set_type(::pb::DHTResponse_Type value);
  private:
  ::pb::DHTResponse_Type _internal_type() const;
  void _internal_set_type(::pb::DHTResponse_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.DHTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::pb::PeerInfo* peer_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PeerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PeerInfo) */ {
 public:
  inline PeerInfo() : PeerInfo(nullptr) {}
  ~PeerInfo() override;
  explicit constexpr PeerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerInfo(const PeerInfo& from);
  PeerInfo(PeerInfo&& from) noexcept
    : PeerInfo() {
    *this = ::std::move(from);
  }

  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerInfo& operator=(PeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerInfo*>(
               &_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PeerInfo& a, PeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PeerInfo";
  }
  protected:
  explicit PeerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated bytes addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const void* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:pb.PeerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class ConnManagerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ConnManagerRequest) */ {
 public:
  inline ConnManagerRequest() : ConnManagerRequest(nullptr) {}
  ~ConnManagerRequest() override;
  explicit constexpr ConnManagerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnManagerRequest(const ConnManagerRequest& from);
  ConnManagerRequest(ConnManagerRequest&& from) noexcept
    : ConnManagerRequest() {
    *this = ::std::move(from);
  }

  inline ConnManagerRequest& operator=(const ConnManagerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnManagerRequest& operator=(ConnManagerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnManagerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnManagerRequest* internal_default_instance() {
    return reinterpret_cast<const ConnManagerRequest*>(
               &_ConnManagerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConnManagerRequest& a, ConnManagerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnManagerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnManagerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnManagerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnManagerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnManagerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnManagerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnManagerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ConnManagerRequest";
  }
  protected:
  explicit ConnManagerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnManagerRequest_Type Type;
  static constexpr Type TAG_PEER =
    ConnManagerRequest_Type_TAG_PEER;
  static constexpr Type UNTAG_PEER =
    ConnManagerRequest_Type_UNTAG_PEER;
  static constexpr Type TRIM =
    ConnManagerRequest_Type_TRIM;
  static inline bool Type_IsValid(int value) {
    return ConnManagerRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ConnManagerRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ConnManagerRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ConnManagerRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ConnManagerRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ConnManagerRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ConnManagerRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 2,
    kTagFieldNumber = 3,
    kWeightFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional bytes peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional int64 weight = 4;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  int64_t weight() const;
  void set_weight(int64_t value);
  private:
  int64_t _internal_weight() const;
  void _internal_set_weight(int64_t value);
  public:

  // optional .pb.ConnManagerRequest.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::ConnManagerRequest_Type type() const;
  void set_type(::pb::ConnManagerRequest_Type value);
  private:
  ::pb::ConnManagerRequest_Type _internal_type() const;
  void _internal_set_type(::pb::ConnManagerRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ConnManagerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  int64_t weight_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class DisconnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.DisconnectRequest) */ {
 public:
  inline DisconnectRequest() : DisconnectRequest(nullptr) {}
  ~DisconnectRequest() override;
  explicit constexpr DisconnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectRequest(const DisconnectRequest& from);
  DisconnectRequest(DisconnectRequest&& from) noexcept
    : DisconnectRequest() {
    *this = ::std::move(from);
  }

  inline DisconnectRequest& operator=(const DisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectRequest& operator=(DisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const DisconnectRequest*>(
               &_DisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DisconnectRequest& a, DisconnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DisconnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.DisconnectRequest";
  }
  protected:
  explicit DisconnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
  };
  // bytes peer = 1;
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // @@protoc_insertion_point(class_scope:pb.DisconnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PSRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PSRequest) */ {
 public:
  inline PSRequest() : PSRequest(nullptr) {}
  ~PSRequest() override;
  explicit constexpr PSRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PSRequest(const PSRequest& from);
  PSRequest(PSRequest&& from) noexcept
    : PSRequest() {
    *this = ::std::move(from);
  }

  inline PSRequest& operator=(const PSRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PSRequest& operator=(PSRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PSRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PSRequest* internal_default_instance() {
    return reinterpret_cast<const PSRequest*>(
               &_PSRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PSRequest& a, PSRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PSRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PSRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PSRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PSRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PSRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PSRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PSRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PSRequest";
  }
  protected:
  explicit PSRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PSRequest_Type Type;
  static constexpr Type GET_TOPICS =
    PSRequest_Type_GET_TOPICS;
  static constexpr Type LIST_PEERS =
    PSRequest_Type_LIST_PEERS;
  static constexpr Type PUBLISH =
    PSRequest_Type_PUBLISH;
  static constexpr Type SUBSCRIBE =
    PSRequest_Type_SUBSCRIBE;
  static inline bool Type_IsValid(int value) {
    return PSRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PSRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PSRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PSRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PSRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PSRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return PSRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kDataFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string topic = 2;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional .pb.PSRequest.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::PSRequest_Type type() const;
  void set_type(::pb::PSRequest_Type value);
  private:
  ::pb::PSRequest_Type _internal_type() const;
  void _internal_set_type(::pb::PSRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PSRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PSMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PSMessage) */ {
 public:
  inline PSMessage() : PSMessage(nullptr) {}
  ~PSMessage() override;
  explicit constexpr PSMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PSMessage(const PSMessage& from);
  PSMessage(PSMessage&& from) noexcept
    : PSMessage() {
    *this = ::std::move(from);
  }

  inline PSMessage& operator=(const PSMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PSMessage& operator=(PSMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PSMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PSMessage* internal_default_instance() {
    return reinterpret_cast<const PSMessage*>(
               &_PSMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PSMessage& a, PSMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PSMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PSMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PSMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PSMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PSMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PSMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PSMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PSMessage";
  }
  protected:
  explicit PSMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicIDsFieldNumber = 4,
    kFromFieldNumber = 1,
    kDataFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kSignatureFieldNumber = 5,
    kKeyFieldNumber = 6,
  };
  // repeated string topicIDs = 4;
  int topicids_size() const;
  private:
  int _internal_topicids_size() const;
  public:
  void clear_topicids();
  const std::string& topicids(int index) const;
  std::string* mutable_topicids(int index);
  void set_topicids(int index, const std::string& value);
  void set_topicids(int index, std::string&& value);
  void set_topicids(int index, const char* value);
  void set_topicids(int index, const char* value, size_t size);
  std::string* add_topicids();
  void add_topicids(const std::string& value);
  void add_topicids(std::string&& value);
  void add_topicids(const char* value);
  void add_topicids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topicids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topicids();
  private:
  const std::string& _internal_topicids(int index) const;
  std::string* _internal_add_topicids();
  public:

  // optional bytes from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes seqno = 3;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  const std::string& seqno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seqno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seqno();
  PROTOBUF_NODISCARD std::string* release_seqno();
  void set_allocated_seqno(std::string* seqno);
  private:
  const std::string& _internal_seqno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seqno(const std::string& value);
  std::string* _internal_mutable_seqno();
  public:

  // optional bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional bytes key = 6;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:pb.PSMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topicids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seqno_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PSResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PSResponse) */ {
 public:
  inline PSResponse() : PSResponse(nullptr) {}
  ~PSResponse() override;
  explicit constexpr PSResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PSResponse(const PSResponse& from);
  PSResponse(PSResponse&& from) noexcept
    : PSResponse() {
    *this = ::std::move(from);
  }

  inline PSResponse& operator=(const PSResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PSResponse& operator=(PSResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PSResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PSResponse* internal_default_instance() {
    return reinterpret_cast<const PSResponse*>(
               &_PSResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PSResponse& a, PSResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PSResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PSResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PSResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PSResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PSResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PSResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PSResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PSResponse";
  }
  protected:
  explicit PSResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 1,
    kPeerIDsFieldNumber = 2,
  };
  // repeated string topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // repeated bytes peerIDs = 2;
  int peerids_size() const;
  private:
  int _internal_peerids_size() const;
  public:
  void clear_peerids();
  const std::string& peerids(int index) const;
  std::string* mutable_peerids(int index);
  void set_peerids(int index, const std::string& value);
  void set_peerids(int index, std::string&& value);
  void set_peerids(int index, const char* value);
  void set_peerids(int index, const void* value, size_t size);
  std::string* add_peerids();
  void add_peerids(const std::string& value);
  void add_peerids(std::string&& value);
  void add_peerids(const char* value);
  void add_peerids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peerids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peerids();
  private:
  const std::string& _internal_peerids(int index) const;
  std::string* _internal_add_peerids();
  public:

  // @@protoc_insertion_point(class_scope:pb.PSResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peerids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PeerstoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PeerstoreRequest) */ {
 public:
  inline PeerstoreRequest() : PeerstoreRequest(nullptr) {}
  ~PeerstoreRequest() override;
  explicit constexpr PeerstoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerstoreRequest(const PeerstoreRequest& from);
  PeerstoreRequest(PeerstoreRequest&& from) noexcept
    : PeerstoreRequest() {
    *this = ::std::move(from);
  }

  inline PeerstoreRequest& operator=(const PeerstoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerstoreRequest& operator=(PeerstoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerstoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerstoreRequest* internal_default_instance() {
    return reinterpret_cast<const PeerstoreRequest*>(
               &_PeerstoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PeerstoreRequest& a, PeerstoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerstoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerstoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerstoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerstoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerstoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeerstoreRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerstoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PeerstoreRequest";
  }
  protected:
  explicit PeerstoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PeerstoreRequest_Type Type;
  static constexpr Type UNSPECIFIED =
    PeerstoreRequest_Type_UNSPECIFIED;
  static constexpr Type GET_PROTOCOLS =
    PeerstoreRequest_Type_GET_PROTOCOLS;
  static constexpr Type GET_PEER_INFO =
    PeerstoreRequest_Type_GET_PEER_INFO;
  static inline bool Type_IsValid(int value) {
    return PeerstoreRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PeerstoreRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PeerstoreRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PeerstoreRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PeerstoreRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PeerstoreRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return PeerstoreRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProtosFieldNumber = 3,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string protos = 3;
  int protos_size() const;
  private:
  int _internal_protos_size() const;
  public:
  void clear_protos();
  const std::string& protos(int index) const;
  std::string* mutable_protos(int index);
  void set_protos(int index, const std::string& value);
  void set_protos(int index, std::string&& value);
  void set_protos(int index, const char* value);
  void set_protos(int index, const char* value, size_t size);
  std::string* add_protos();
  void add_protos(const std::string& value);
  void add_protos(std::string&& value);
  void add_protos(const char* value);
  void add_protos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& protos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_protos();
  private:
  const std::string& _internal_protos(int index) const;
  std::string* _internal_add_protos();
  public:

  // optional bytes id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .pb.PeerstoreRequest.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pb::PeerstoreRequest_Type type() const;
  void set_type(::pb::PeerstoreRequest_Type value);
  private:
  ::pb::PeerstoreRequest_Type _internal_type() const;
  void _internal_set_type(::pb::PeerstoreRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PeerstoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> protos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int type_;
  friend struct ::TableStruct_interop_2eproto;
};
// -------------------------------------------------------------------

class PeerstoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PeerstoreResponse) */ {
 public:
  inline PeerstoreResponse() : PeerstoreResponse(nullptr) {}
  ~PeerstoreResponse() override;
  explicit constexpr PeerstoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerstoreResponse(const PeerstoreResponse& from);
  PeerstoreResponse(PeerstoreResponse&& from) noexcept
    : PeerstoreResponse() {
    *this = ::std::move(from);
  }

  inline PeerstoreResponse& operator=(const PeerstoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerstoreResponse& operator=(PeerstoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerstoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerstoreResponse* internal_default_instance() {
    return reinterpret_cast<const PeerstoreResponse*>(
               &_PeerstoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PeerstoreResponse& a, PeerstoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerstoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerstoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerstoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerstoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerstoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeerstoreResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerstoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PeerstoreResponse";
  }
  protected:
  explicit PeerstoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtosFieldNumber = 2,
    kPeerFieldNumber = 1,
  };
  // repeated string protos = 2;
  int protos_size() const;
  private:
  int _internal_protos_size() const;
  public:
  void clear_protos();
  const std::string& protos(int index) const;
  std::string* mutable_protos(int index);
  void set_protos(int index, const std::string& value);
  void set_protos(int index, std::string&& value);
  void set_protos(int index, const char* value);
  void set_protos(int index, const char* value, size_t size);
  std::string* add_protos();
  void add_protos(const std::string& value);
  void add_protos(std::string&& value);
  void add_protos(const char* value);
  void add_protos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& protos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_protos();
  private:
  const std::string& _internal_protos(int index) const;
  std::string* _internal_add_protos();
  public:

  // optional .pb.PeerInfo peer = 1;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::pb::PeerInfo& peer() const;
  PROTOBUF_NODISCARD ::pb::PeerInfo* release_peer();
  ::pb::PeerInfo* mutable_peer();
  void set_allocated_peer(::pb::PeerInfo* peer);
  private:
  const ::pb::PeerInfo& _internal_peer() const;
  ::pb::PeerInfo* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::pb::PeerInfo* peer);
  ::pb::PeerInfo* unsafe_arena_release_peer();

  // @@protoc_insertion_point(class_scope:pb.PeerstoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> protos_;
  ::pb::PeerInfo* peer_;
  friend struct ::TableStruct_interop_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// optional .pb.Request.Type type = 1;
inline bool Request::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Request::has_type() const {
  return _internal_has_type();
}
inline void Request::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::pb::Request_Type Request::_internal_type() const {
  return static_cast< ::pb::Request_Type >(type_);
}
inline ::pb::Request_Type Request::type() const {
  // @@protoc_insertion_point(field_get:pb.Request.type)
  return _internal_type();
}
inline void Request::_internal_set_type(::pb::Request_Type value) {
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void Request::set_type(::pb::Request_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.Request.type)
}

// optional .pb.ConnectRequest connect = 2;
inline bool Request::_internal_has_connect() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || connect_ != nullptr);
  return value;
}
inline bool Request::has_connect() const {
  return _internal_has_connect();
}
inline void Request::clear_connect() {
  if (connect_ != nullptr) connect_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::ConnectRequest& Request::_internal_connect() const {
  const ::pb::ConnectRequest* p = connect_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::ConnectRequest&>(
      ::pb::_ConnectRequest_default_instance_);
}
inline const ::pb::ConnectRequest& Request::connect() const {
  // @@protoc_insertion_point(field_get:pb.Request.connect)
  return _internal_connect();
}
inline void Request::unsafe_arena_set_allocated_connect(
    ::pb::ConnectRequest* connect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connect_);
  }
  connect_ = connect;
  if (connect) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.connect)
}
inline ::pb::ConnectRequest* Request::release_connect() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::ConnectRequest* temp = connect_;
  connect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::ConnectRequest* Request::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_release:pb.Request.connect)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::ConnectRequest* temp = connect_;
  connect_ = nullptr;
  return temp;
}
inline ::pb::ConnectRequest* Request::_internal_mutable_connect() {
  _has_bits_[0] |= 0x00000001u;
  if (connect_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ConnectRequest>(GetArenaForAllocation());
    connect_ = p;
  }
  return connect_;
}
inline ::pb::ConnectRequest* Request::mutable_connect() {
  ::pb::ConnectRequest* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:pb.Request.connect)
  return _msg;
}
inline void Request::set_allocated_connect(::pb::ConnectRequest* connect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connect_;
  }
  if (connect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::ConnectRequest>::GetOwningArena(connect);
    if (message_arena != submessage_arena) {
      connect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  connect_ = connect;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.connect)
}

// optional .pb.StreamOpenRequest streamOpen = 3;
inline bool Request::_internal_has_streamopen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || streamopen_ != nullptr);
  return value;
}
inline bool Request::has_streamopen() const {
  return _internal_has_streamopen();
}
inline void Request::clear_streamopen() {
  if (streamopen_ != nullptr) streamopen_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::StreamOpenRequest& Request::_internal_streamopen() const {
  const ::pb::StreamOpenRequest* p = streamopen_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::StreamOpenRequest&>(
      ::pb::_StreamOpenRequest_default_instance_);
}
inline const ::pb::StreamOpenRequest& Request::streamopen() const {
  // @@protoc_insertion_point(field_get:pb.Request.streamOpen)
  return _internal_streamopen();
}
inline void Request::unsafe_arena_set_allocated_streamopen(
    ::pb::StreamOpenRequest* streamopen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(streamopen_);
  }
  streamopen_ = streamopen;
  if (streamopen) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.streamOpen)
}
inline ::pb::StreamOpenRequest* Request::release_streamopen() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::StreamOpenRequest* temp = streamopen_;
  streamopen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::StreamOpenRequest* Request::unsafe_arena_release_streamopen() {
  // @@protoc_insertion_point(field_release:pb.Request.streamOpen)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::StreamOpenRequest* temp = streamopen_;
  streamopen_ = nullptr;
  return temp;
}
inline ::pb::StreamOpenRequest* Request::_internal_mutable_streamopen() {
  _has_bits_[0] |= 0x00000002u;
  if (streamopen_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::StreamOpenRequest>(GetArenaForAllocation());
    streamopen_ = p;
  }
  return streamopen_;
}
inline ::pb::StreamOpenRequest* Request::mutable_streamopen() {
  ::pb::StreamOpenRequest* _msg = _internal_mutable_streamopen();
  // @@protoc_insertion_point(field_mutable:pb.Request.streamOpen)
  return _msg;
}
inline void Request::set_allocated_streamopen(::pb::StreamOpenRequest* streamopen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete streamopen_;
  }
  if (streamopen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::StreamOpenRequest>::GetOwningArena(streamopen);
    if (message_arena != submessage_arena) {
      streamopen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streamopen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  streamopen_ = streamopen;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.streamOpen)
}

// optional .pb.StreamHandlerRequest streamHandler = 4;
inline bool Request::_internal_has_streamhandler() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || streamhandler_ != nullptr);
  return value;
}
inline bool Request::has_streamhandler() const {
  return _internal_has_streamhandler();
}
inline void Request::clear_streamhandler() {
  if (streamhandler_ != nullptr) streamhandler_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::StreamHandlerRequest& Request::_internal_streamhandler() const {
  const ::pb::StreamHandlerRequest* p = streamhandler_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::StreamHandlerRequest&>(
      ::pb::_StreamHandlerRequest_default_instance_);
}
inline const ::pb::StreamHandlerRequest& Request::streamhandler() const {
  // @@protoc_insertion_point(field_get:pb.Request.streamHandler)
  return _internal_streamhandler();
}
inline void Request::unsafe_arena_set_allocated_streamhandler(
    ::pb::StreamHandlerRequest* streamhandler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(streamhandler_);
  }
  streamhandler_ = streamhandler;
  if (streamhandler) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.streamHandler)
}
inline ::pb::StreamHandlerRequest* Request::release_streamhandler() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::StreamHandlerRequest* temp = streamhandler_;
  streamhandler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::StreamHandlerRequest* Request::unsafe_arena_release_streamhandler() {
  // @@protoc_insertion_point(field_release:pb.Request.streamHandler)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::StreamHandlerRequest* temp = streamhandler_;
  streamhandler_ = nullptr;
  return temp;
}
inline ::pb::StreamHandlerRequest* Request::_internal_mutable_streamhandler() {
  _has_bits_[0] |= 0x00000004u;
  if (streamhandler_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::StreamHandlerRequest>(GetArenaForAllocation());
    streamhandler_ = p;
  }
  return streamhandler_;
}
inline ::pb::StreamHandlerRequest* Request::mutable_streamhandler() {
  ::pb::StreamHandlerRequest* _msg = _internal_mutable_streamhandler();
  // @@protoc_insertion_point(field_mutable:pb.Request.streamHandler)
  return _msg;
}
inline void Request::set_allocated_streamhandler(::pb::StreamHandlerRequest* streamhandler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete streamhandler_;
  }
  if (streamhandler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::StreamHandlerRequest>::GetOwningArena(streamhandler);
    if (message_arena != submessage_arena) {
      streamhandler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streamhandler, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  streamhandler_ = streamhandler;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.streamHandler)
}

// optional .pb.DHTRequest dht = 5;
inline bool Request::_internal_has_dht() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || dht_ != nullptr);
  return value;
}
inline bool Request::has_dht() const {
  return _internal_has_dht();
}
inline void Request::clear_dht() {
  if (dht_ != nullptr) dht_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pb::DHTRequest& Request::_internal_dht() const {
  const ::pb::DHTRequest* p = dht_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::DHTRequest&>(
      ::pb::_DHTRequest_default_instance_);
}
inline const ::pb::DHTRequest& Request::dht() const {
  // @@protoc_insertion_point(field_get:pb.Request.dht)
  return _internal_dht();
}
inline void Request::unsafe_arena_set_allocated_dht(
    ::pb::DHTRequest* dht) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dht_);
  }
  dht_ = dht;
  if (dht) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.dht)
}
inline ::pb::DHTRequest* Request::release_dht() {
  _has_bits_[0] &= ~0x00000008u;
  ::pb::DHTRequest* temp = dht_;
  dht_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::DHTRequest* Request::unsafe_arena_release_dht() {
  // @@protoc_insertion_point(field_release:pb.Request.dht)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::DHTRequest* temp = dht_;
  dht_ = nullptr;
  return temp;
}
inline ::pb::DHTRequest* Request::_internal_mutable_dht() {
  _has_bits_[0] |= 0x00000008u;
  if (dht_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::DHTRequest>(GetArenaForAllocation());
    dht_ = p;
  }
  return dht_;
}
inline ::pb::DHTRequest* Request::mutable_dht() {
  ::pb::DHTRequest* _msg = _internal_mutable_dht();
  // @@protoc_insertion_point(field_mutable:pb.Request.dht)
  return _msg;
}
inline void Request::set_allocated_dht(::pb::DHTRequest* dht) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dht_;
  }
  if (dht) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::DHTRequest>::GetOwningArena(dht);
    if (message_arena != submessage_arena) {
      dht = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dht, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dht_ = dht;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.dht)
}

// optional .pb.ConnManagerRequest connManager = 6;
inline bool Request::_internal_has_connmanager() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || connmanager_ != nullptr);
  return value;
}
inline bool Request::has_connmanager() const {
  return _internal_has_connmanager();
}
inline void Request::clear_connmanager() {
  if (connmanager_ != nullptr) connmanager_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pb::ConnManagerRequest& Request::_internal_connmanager() const {
  const ::pb::ConnManagerRequest* p = connmanager_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::ConnManagerRequest&>(
      ::pb::_ConnManagerRequest_default_instance_);
}
inline const ::pb::ConnManagerRequest& Request::connmanager() const {
  // @@protoc_insertion_point(field_get:pb.Request.connManager)
  return _internal_connmanager();
}
inline void Request::unsafe_arena_set_allocated_connmanager(
    ::pb::ConnManagerRequest* connmanager) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connmanager_);
  }
  connmanager_ = connmanager;
  if (connmanager) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.connManager)
}
inline ::pb::ConnManagerRequest* Request::release_connmanager() {
  _has_bits_[0] &= ~0x00000010u;
  ::pb::ConnManagerRequest* temp = connmanager_;
  connmanager_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::ConnManagerRequest* Request::unsafe_arena_release_connmanager() {
  // @@protoc_insertion_point(field_release:pb.Request.connManager)
  _has_bits_[0] &= ~0x00000010u;
  ::pb::ConnManagerRequest* temp = connmanager_;
  connmanager_ = nullptr;
  return temp;
}
inline ::pb::ConnManagerRequest* Request::_internal_mutable_connmanager() {
  _has_bits_[0] |= 0x00000010u;
  if (connmanager_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ConnManagerRequest>(GetArenaForAllocation());
    connmanager_ = p;
  }
  return connmanager_;
}
inline ::pb::ConnManagerRequest* Request::mutable_connmanager() {
  ::pb::ConnManagerRequest* _msg = _internal_mutable_connmanager();
  // @@protoc_insertion_point(field_mutable:pb.Request.connManager)
  return _msg;
}
inline void Request::set_allocated_connmanager(::pb::ConnManagerRequest* connmanager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connmanager_;
  }
  if (connmanager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::ConnManagerRequest>::GetOwningArena(connmanager);
    if (message_arena != submessage_arena) {
      connmanager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connmanager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  connmanager_ = connmanager;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.connManager)
}

// optional .pb.DisconnectRequest disconnect = 7;
inline bool Request::_internal_has_disconnect() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || disconnect_ != nullptr);
  return value;
}
inline bool Request::has_disconnect() const {
  return _internal_has_disconnect();
}
inline void Request::clear_disconnect() {
  if (disconnect_ != nullptr) disconnect_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pb::DisconnectRequest& Request::_internal_disconnect() const {
  const ::pb::DisconnectRequest* p = disconnect_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::DisconnectRequest&>(
      ::pb::_DisconnectRequest_default_instance_);
}
inline const ::pb::DisconnectRequest& Request::disconnect() const {
  // @@protoc_insertion_point(field_get:pb.Request.disconnect)
  return _internal_disconnect();
}
inline void Request::unsafe_arena_set_allocated_disconnect(
    ::pb::DisconnectRequest* disconnect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disconnect_);
  }
  disconnect_ = disconnect;
  if (disconnect) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.disconnect)
}
inline ::pb::DisconnectRequest* Request::release_disconnect() {
  _has_bits_[0] &= ~0x00000020u;
  ::pb::DisconnectRequest* temp = disconnect_;
  disconnect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::DisconnectRequest* Request::unsafe_arena_release_disconnect() {
  // @@protoc_insertion_point(field_release:pb.Request.disconnect)
  _has_bits_[0] &= ~0x00000020u;
  ::pb::DisconnectRequest* temp = disconnect_;
  disconnect_ = nullptr;
  return temp;
}
inline ::pb::DisconnectRequest* Request::_internal_mutable_disconnect() {
  _has_bits_[0] |= 0x00000020u;
  if (disconnect_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::DisconnectRequest>(GetArenaForAllocation());
    disconnect_ = p;
  }
  return disconnect_;
}
inline ::pb::DisconnectRequest* Request::mutable_disconnect() {
  ::pb::DisconnectRequest* _msg = _internal_mutable_disconnect();
  // @@protoc_insertion_point(field_mutable:pb.Request.disconnect)
  return _msg;
}
inline void Request::set_allocated_disconnect(::pb::DisconnectRequest* disconnect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete disconnect_;
  }
  if (disconnect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::DisconnectRequest>::GetOwningArena(disconnect);
    if (message_arena != submessage_arena) {
      disconnect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disconnect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  disconnect_ = disconnect;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.disconnect)
}

// optional .pb.PSRequest pubsub = 8;
inline bool Request::_internal_has_pubsub() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || pubsub_ != nullptr);
  return value;
}
inline bool Request::has_pubsub() const {
  return _internal_has_pubsub();
}
inline void Request::clear_pubsub() {
  if (pubsub_ != nullptr) pubsub_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::pb::PSRequest& Request::_internal_pubsub() const {
  const ::pb::PSRequest* p = pubsub_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PSRequest&>(
      ::pb::_PSRequest_default_instance_);
}
inline const ::pb::PSRequest& Request::pubsub() const {
  // @@protoc_insertion_point(field_get:pb.Request.pubsub)
  return _internal_pubsub();
}
inline void Request::unsafe_arena_set_allocated_pubsub(
    ::pb::PSRequest* pubsub) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pubsub_);
  }
  pubsub_ = pubsub;
  if (pubsub) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.pubsub)
}
inline ::pb::PSRequest* Request::release_pubsub() {
  _has_bits_[0] &= ~0x00000040u;
  ::pb::PSRequest* temp = pubsub_;
  pubsub_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PSRequest* Request::unsafe_arena_release_pubsub() {
  // @@protoc_insertion_point(field_release:pb.Request.pubsub)
  _has_bits_[0] &= ~0x00000040u;
  ::pb::PSRequest* temp = pubsub_;
  pubsub_ = nullptr;
  return temp;
}
inline ::pb::PSRequest* Request::_internal_mutable_pubsub() {
  _has_bits_[0] |= 0x00000040u;
  if (pubsub_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PSRequest>(GetArenaForAllocation());
    pubsub_ = p;
  }
  return pubsub_;
}
inline ::pb::PSRequest* Request::mutable_pubsub() {
  ::pb::PSRequest* _msg = _internal_mutable_pubsub();
  // @@protoc_insertion_point(field_mutable:pb.Request.pubsub)
  return _msg;
}
inline void Request::set_allocated_pubsub(::pb::PSRequest* pubsub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pubsub_;
  }
  if (pubsub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PSRequest>::GetOwningArena(pubsub);
    if (message_arena != submessage_arena) {
      pubsub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pubsub, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  pubsub_ = pubsub;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.pubsub)
}

// optional .pb.PeerstoreRequest peerStore = 9;
inline bool Request::_internal_has_peerstore() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || peerstore_ != nullptr);
  return value;
}
inline bool Request::has_peerstore() const {
  return _internal_has_peerstore();
}
inline void Request::clear_peerstore() {
  if (peerstore_ != nullptr) peerstore_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::pb::PeerstoreRequest& Request::_internal_peerstore() const {
  const ::pb::PeerstoreRequest* p = peerstore_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PeerstoreRequest&>(
      ::pb::_PeerstoreRequest_default_instance_);
}
inline const ::pb::PeerstoreRequest& Request::peerstore() const {
  // @@protoc_insertion_point(field_get:pb.Request.peerStore)
  return _internal_peerstore();
}
inline void Request::unsafe_arena_set_allocated_peerstore(
    ::pb::PeerstoreRequest* peerstore) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peerstore_);
  }
  peerstore_ = peerstore;
  if (peerstore) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Request.peerStore)
}
inline ::pb::PeerstoreRequest* Request::release_peerstore() {
  _has_bits_[0] &= ~0x00000080u;
  ::pb::PeerstoreRequest* temp = peerstore_;
  peerstore_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PeerstoreRequest* Request::unsafe_arena_release_peerstore() {
  // @@protoc_insertion_point(field_release:pb.Request.peerStore)
  _has_bits_[0] &= ~0x00000080u;
  ::pb::PeerstoreRequest* temp = peerstore_;
  peerstore_ = nullptr;
  return temp;
}
inline ::pb::PeerstoreRequest* Request::_internal_mutable_peerstore() {
  _has_bits_[0] |= 0x00000080u;
  if (peerstore_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PeerstoreRequest>(GetArenaForAllocation());
    peerstore_ = p;
  }
  return peerstore_;
}
inline ::pb::PeerstoreRequest* Request::mutable_peerstore() {
  ::pb::PeerstoreRequest* _msg = _internal_mutable_peerstore();
  // @@protoc_insertion_point(field_mutable:pb.Request.peerStore)
  return _msg;
}
inline void Request::set_allocated_peerstore(::pb::PeerstoreRequest* peerstore) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peerstore_;
  }
  if (peerstore) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PeerstoreRequest>::GetOwningArena(peerstore);
    if (message_arena != submessage_arena) {
      peerstore = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peerstore, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  peerstore_ = peerstore;
  // @@protoc_insertion_point(field_set_allocated:pb.Request.peerStore)
}

// -------------------------------------------------------------------

// Response

// optional .pb.Response.Type type = 1;
inline bool Response::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Response::has_type() const {
  return _internal_has_type();
}
inline void Response::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::pb::Response_Type Response::_internal_type() const {
  return static_cast< ::pb::Response_Type >(type_);
}
inline ::pb::Response_Type Response::type() const {
  // @@protoc_insertion_point(field_get:pb.Response.type)
  return _internal_type();
}
inline void Response::_internal_set_type(::pb::Response_Type value) {
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void Response::set_type(::pb::Response_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.Response.type)
}

// optional .pb.ErrorResponse error = 2;
inline bool Response::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool Response::has_error() const {
  return _internal_has_error();
}
inline void Response::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::ErrorResponse& Response::_internal_error() const {
  const ::pb::ErrorResponse* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::ErrorResponse&>(
      ::pb::_ErrorResponse_default_instance_);
}
inline const ::pb::ErrorResponse& Response::error() const {
  // @@protoc_insertion_point(field_get:pb.Response.error)
  return _internal_error();
}
inline void Response::unsafe_arena_set_allocated_error(
    ::pb::ErrorResponse* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.error)
}
inline ::pb::ErrorResponse* Response::release_error() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::ErrorResponse* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::ErrorResponse* Response::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:pb.Response.error)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::ErrorResponse* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::pb::ErrorResponse* Response::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ErrorResponse>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::pb::ErrorResponse* Response::mutable_error() {
  ::pb::ErrorResponse* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:pb.Response.error)
  return _msg;
}
inline void Response::set_allocated_error(::pb::ErrorResponse* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::ErrorResponse>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.error)
}

// optional .pb.StreamInfo streamInfo = 3;
inline bool Response::_internal_has_streaminfo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || streaminfo_ != nullptr);
  return value;
}
inline bool Response::has_streaminfo() const {
  return _internal_has_streaminfo();
}
inline void Response::clear_streaminfo() {
  if (streaminfo_ != nullptr) streaminfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::StreamInfo& Response::_internal_streaminfo() const {
  const ::pb::StreamInfo* p = streaminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::StreamInfo&>(
      ::pb::_StreamInfo_default_instance_);
}
inline const ::pb::StreamInfo& Response::streaminfo() const {
  // @@protoc_insertion_point(field_get:pb.Response.streamInfo)
  return _internal_streaminfo();
}
inline void Response::unsafe_arena_set_allocated_streaminfo(
    ::pb::StreamInfo* streaminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(streaminfo_);
  }
  streaminfo_ = streaminfo;
  if (streaminfo) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.streamInfo)
}
inline ::pb::StreamInfo* Response::release_streaminfo() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::StreamInfo* temp = streaminfo_;
  streaminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::StreamInfo* Response::unsafe_arena_release_streaminfo() {
  // @@protoc_insertion_point(field_release:pb.Response.streamInfo)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::StreamInfo* temp = streaminfo_;
  streaminfo_ = nullptr;
  return temp;
}
inline ::pb::StreamInfo* Response::_internal_mutable_streaminfo() {
  _has_bits_[0] |= 0x00000002u;
  if (streaminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::StreamInfo>(GetArenaForAllocation());
    streaminfo_ = p;
  }
  return streaminfo_;
}
inline ::pb::StreamInfo* Response::mutable_streaminfo() {
  ::pb::StreamInfo* _msg = _internal_mutable_streaminfo();
  // @@protoc_insertion_point(field_mutable:pb.Response.streamInfo)
  return _msg;
}
inline void Response::set_allocated_streaminfo(::pb::StreamInfo* streaminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete streaminfo_;
  }
  if (streaminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::StreamInfo>::GetOwningArena(streaminfo);
    if (message_arena != submessage_arena) {
      streaminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streaminfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  streaminfo_ = streaminfo;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.streamInfo)
}

// optional .pb.IdentifyResponse identify = 4;
inline bool Response::_internal_has_identify() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || identify_ != nullptr);
  return value;
}
inline bool Response::has_identify() const {
  return _internal_has_identify();
}
inline void Response::clear_identify() {
  if (identify_ != nullptr) identify_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pb::IdentifyResponse& Response::_internal_identify() const {
  const ::pb::IdentifyResponse* p = identify_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::IdentifyResponse&>(
      ::pb::_IdentifyResponse_default_instance_);
}
inline const ::pb::IdentifyResponse& Response::identify() const {
  // @@protoc_insertion_point(field_get:pb.Response.identify)
  return _internal_identify();
}
inline void Response::unsafe_arena_set_allocated_identify(
    ::pb::IdentifyResponse* identify) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identify_);
  }
  identify_ = identify;
  if (identify) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.identify)
}
inline ::pb::IdentifyResponse* Response::release_identify() {
  _has_bits_[0] &= ~0x00000004u;
  ::pb::IdentifyResponse* temp = identify_;
  identify_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::IdentifyResponse* Response::unsafe_arena_release_identify() {
  // @@protoc_insertion_point(field_release:pb.Response.identify)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::IdentifyResponse* temp = identify_;
  identify_ = nullptr;
  return temp;
}
inline ::pb::IdentifyResponse* Response::_internal_mutable_identify() {
  _has_bits_[0] |= 0x00000004u;
  if (identify_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::IdentifyResponse>(GetArenaForAllocation());
    identify_ = p;
  }
  return identify_;
}
inline ::pb::IdentifyResponse* Response::mutable_identify() {
  ::pb::IdentifyResponse* _msg = _internal_mutable_identify();
  // @@protoc_insertion_point(field_mutable:pb.Response.identify)
  return _msg;
}
inline void Response::set_allocated_identify(::pb::IdentifyResponse* identify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete identify_;
  }
  if (identify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::IdentifyResponse>::GetOwningArena(identify);
    if (message_arena != submessage_arena) {
      identify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identify, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  identify_ = identify;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.identify)
}

// optional .pb.DHTResponse dht = 5;
inline bool Response::_internal_has_dht() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || dht_ != nullptr);
  return value;
}
inline bool Response::has_dht() const {
  return _internal_has_dht();
}
inline void Response::clear_dht() {
  if (dht_ != nullptr) dht_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pb::DHTResponse& Response::_internal_dht() const {
  const ::pb::DHTResponse* p = dht_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::DHTResponse&>(
      ::pb::_DHTResponse_default_instance_);
}
inline const ::pb::DHTResponse& Response::dht() const {
  // @@protoc_insertion_point(field_get:pb.Response.dht)
  return _internal_dht();
}
inline void Response::unsafe_arena_set_allocated_dht(
    ::pb::DHTResponse* dht) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dht_);
  }
  dht_ = dht;
  if (dht) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.dht)
}
inline ::pb::DHTResponse* Response::release_dht() {
  _has_bits_[0] &= ~0x00000008u;
  ::pb::DHTResponse* temp = dht_;
  dht_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::DHTResponse* Response::unsafe_arena_release_dht() {
  // @@protoc_insertion_point(field_release:pb.Response.dht)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::DHTResponse* temp = dht_;
  dht_ = nullptr;
  return temp;
}
inline ::pb::DHTResponse* Response::_internal_mutable_dht() {
  _has_bits_[0] |= 0x00000008u;
  if (dht_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::DHTResponse>(GetArenaForAllocation());
    dht_ = p;
  }
  return dht_;
}
inline ::pb::DHTResponse* Response::mutable_dht() {
  ::pb::DHTResponse* _msg = _internal_mutable_dht();
  // @@protoc_insertion_point(field_mutable:pb.Response.dht)
  return _msg;
}
inline void Response::set_allocated_dht(::pb::DHTResponse* dht) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dht_;
  }
  if (dht) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::DHTResponse>::GetOwningArena(dht);
    if (message_arena != submessage_arena) {
      dht = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dht, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dht_ = dht;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.dht)
}

// repeated .pb.PeerInfo peers = 6;
inline int Response::_internal_peers_size() const {
  return peers_.size();
}
inline int Response::peers_size() const {
  return _internal_peers_size();
}
inline void Response::clear_peers() {
  peers_.Clear();
}
inline ::pb::PeerInfo* Response::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Response.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PeerInfo >*
Response::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:pb.Response.peers)
  return &peers_;
}
inline const ::pb::PeerInfo& Response::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::pb::PeerInfo& Response::peers(int index) const {
  // @@protoc_insertion_point(field_get:pb.Response.peers)
  return _internal_peers(index);
}
inline ::pb::PeerInfo* Response::_internal_add_peers() {
  return peers_.Add();
}
inline ::pb::PeerInfo* Response::add_peers() {
  ::pb::PeerInfo* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:pb.Response.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PeerInfo >&
Response::peers() const {
  // @@protoc_insertion_point(field_list:pb.Response.peers)
  return peers_;
}

// optional .pb.PSResponse pubsub = 7;
inline bool Response::_internal_has_pubsub() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || pubsub_ != nullptr);
  return value;
}
inline bool Response::has_pubsub() const {
  return _internal_has_pubsub();
}
inline void Response::clear_pubsub() {
  if (pubsub_ != nullptr) pubsub_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pb::PSResponse& Response::_internal_pubsub() const {
  const ::pb::PSResponse* p = pubsub_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PSResponse&>(
      ::pb::_PSResponse_default_instance_);
}
inline const ::pb::PSResponse& Response::pubsub() const {
  // @@protoc_insertion_point(field_get:pb.Response.pubsub)
  return _internal_pubsub();
}
inline void Response::unsafe_arena_set_allocated_pubsub(
    ::pb::PSResponse* pubsub) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pubsub_);
  }
  pubsub_ = pubsub;
  if (pubsub) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.pubsub)
}
inline ::pb::PSResponse* Response::release_pubsub() {
  _has_bits_[0] &= ~0x00000010u;
  ::pb::PSResponse* temp = pubsub_;
  pubsub_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PSResponse* Response::unsafe_arena_release_pubsub() {
  // @@protoc_insertion_point(field_release:pb.Response.pubsub)
  _has_bits_[0] &= ~0x00000010u;
  ::pb::PSResponse* temp = pubsub_;
  pubsub_ = nullptr;
  return temp;
}
inline ::pb::PSResponse* Response::_internal_mutable_pubsub() {
  _has_bits_[0] |= 0x00000010u;
  if (pubsub_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PSResponse>(GetArenaForAllocation());
    pubsub_ = p;
  }
  return pubsub_;
}
inline ::pb::PSResponse* Response::mutable_pubsub() {
  ::pb::PSResponse* _msg = _internal_mutable_pubsub();
  // @@protoc_insertion_point(field_mutable:pb.Response.pubsub)
  return _msg;
}
inline void Response::set_allocated_pubsub(::pb::PSResponse* pubsub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pubsub_;
  }
  if (pubsub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PSResponse>::GetOwningArena(pubsub);
    if (message_arena != submessage_arena) {
      pubsub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pubsub, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  pubsub_ = pubsub;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.pubsub)
}

// optional .pb.PeerstoreResponse peerStore = 8;
inline bool Response::_internal_has_peerstore() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || peerstore_ != nullptr);
  return value;
}
inline bool Response::has_peerstore() const {
  return _internal_has_peerstore();
}
inline void Response::clear_peerstore() {
  if (peerstore_ != nullptr) peerstore_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pb::PeerstoreResponse& Response::_internal_peerstore() const {
  const ::pb::PeerstoreResponse* p = peerstore_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PeerstoreResponse&>(
      ::pb::_PeerstoreResponse_default_instance_);
}
inline const ::pb::PeerstoreResponse& Response::peerstore() const {
  // @@protoc_insertion_point(field_get:pb.Response.peerStore)
  return _internal_peerstore();
}
inline void Response::unsafe_arena_set_allocated_peerstore(
    ::pb::PeerstoreResponse* peerstore) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peerstore_);
  }
  peerstore_ = peerstore;
  if (peerstore) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Response.peerStore)
}
inline ::pb::PeerstoreResponse* Response::release_peerstore() {
  _has_bits_[0] &= ~0x00000020u;
  ::pb::PeerstoreResponse* temp = peerstore_;
  peerstore_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PeerstoreResponse* Response::unsafe_arena_release_peerstore() {
  // @@protoc_insertion_point(field_release:pb.Response.peerStore)
  _has_bits_[0] &= ~0x00000020u;
  ::pb::PeerstoreResponse* temp = peerstore_;
  peerstore_ = nullptr;
  return temp;
}
inline ::pb::PeerstoreResponse* Response::_internal_mutable_peerstore() {
  _has_bits_[0] |= 0x00000020u;
  if (peerstore_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PeerstoreResponse>(GetArenaForAllocation());
    peerstore_ = p;
  }
  return peerstore_;
}
inline ::pb::PeerstoreResponse* Response::mutable_peerstore() {
  ::pb::PeerstoreResponse* _msg = _internal_mutable_peerstore();
  // @@protoc_insertion_point(field_mutable:pb.Response.peerStore)
  return _msg;
}
inline void Response::set_allocated_peerstore(::pb::PeerstoreResponse* peerstore) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peerstore_;
  }
  if (peerstore) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PeerstoreResponse>::GetOwningArena(peerstore);
    if (message_arena != submessage_arena) {
      peerstore = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peerstore, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  peerstore_ = peerstore;
  // @@protoc_insertion_point(field_set_allocated:pb.Response.peerStore)
}

// -------------------------------------------------------------------

// IdentifyResponse

// bytes id = 1;
inline void IdentifyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& IdentifyResponse::id() const {
  // @@protoc_insertion_point(field_get:pb.IdentifyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IdentifyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IdentifyResponse.id)
}
inline std::string* IdentifyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:pb.IdentifyResponse.id)
  return _s;
}
inline const std::string& IdentifyResponse::_internal_id() const {
  return id_.Get();
}
inline void IdentifyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IdentifyResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IdentifyResponse::release_id() {
  // @@protoc_insertion_point(field_release:pb.IdentifyResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IdentifyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.IdentifyResponse.id)
}

// repeated bytes addrs = 2;
inline int IdentifyResponse::_internal_addrs_size() const {
  return addrs_.size();
}
inline int IdentifyResponse::addrs_size() const {
  return _internal_addrs_size();
}
inline void IdentifyResponse::clear_addrs() {
  addrs_.Clear();
}
inline std::string* IdentifyResponse::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:pb.IdentifyResponse.addrs)
  return _s;
}
inline const std::string& IdentifyResponse::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& IdentifyResponse::addrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.IdentifyResponse.addrs)
  return _internal_addrs(index);
}
inline std::string* IdentifyResponse::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.IdentifyResponse.addrs)
  return addrs_.Mutable(index);
}
inline void IdentifyResponse::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::set_addrs(int index, const void* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.IdentifyResponse.addrs)
}
inline std::string* IdentifyResponse::_internal_add_addrs() {
  return addrs_.Add();
}
inline void IdentifyResponse::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.IdentifyResponse.addrs)
}
inline void IdentifyResponse::add_addrs(const void* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.IdentifyResponse.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IdentifyResponse::addrs() const {
  // @@protoc_insertion_point(field_list:pb.IdentifyResponse.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IdentifyResponse::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.IdentifyResponse.addrs)
  return &addrs_;
}

// -------------------------------------------------------------------

// ConnectRequest

// bytes peer = 1;
inline void ConnectRequest::clear_peer() {
  peer_.ClearToEmpty();
}
inline const std::string& ConnectRequest::peer() const {
  // @@protoc_insertion_point(field_get:pb.ConnectRequest.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectRequest::set_peer(ArgT0&& arg0, ArgT... args) {
 
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ConnectRequest.peer)
}
inline std::string* ConnectRequest::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.ConnectRequest.peer)
  return _s;
}
inline const std::string& ConnectRequest::_internal_peer() const {
  return peer_.Get();
}
inline void ConnectRequest::_internal_set_peer(const std::string& value) {
  
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectRequest::_internal_mutable_peer() {
  
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectRequest::release_peer() {
  // @@protoc_insertion_point(field_release:pb.ConnectRequest.peer)
  return peer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConnectRequest::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    
  } else {
    
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ConnectRequest.peer)
}

// repeated bytes addrs = 2;
inline int ConnectRequest::_internal_addrs_size() const {
  return addrs_.size();
}
inline int ConnectRequest::addrs_size() const {
  return _internal_addrs_size();
}
inline void ConnectRequest::clear_addrs() {
  addrs_.Clear();
}
inline std::string* ConnectRequest::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:pb.ConnectRequest.addrs)
  return _s;
}
inline const std::string& ConnectRequest::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& ConnectRequest::addrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.ConnectRequest.addrs)
  return _internal_addrs(index);
}
inline std::string* ConnectRequest::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ConnectRequest.addrs)
  return addrs_.Mutable(index);
}
inline void ConnectRequest::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::set_addrs(int index, const void* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ConnectRequest.addrs)
}
inline std::string* ConnectRequest::_internal_add_addrs() {
  return addrs_.Add();
}
inline void ConnectRequest::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.ConnectRequest.addrs)
}
inline void ConnectRequest::add_addrs(const void* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.ConnectRequest.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConnectRequest::addrs() const {
  // @@protoc_insertion_point(field_list:pb.ConnectRequest.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConnectRequest::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.ConnectRequest.addrs)
  return &addrs_;
}

// optional int64 timeout = 3;
inline bool ConnectRequest::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectRequest::has_timeout() const {
  return _internal_has_timeout();
}
inline void ConnectRequest::clear_timeout() {
  timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t ConnectRequest::_internal_timeout() const {
  return timeout_;
}
inline int64_t ConnectRequest::timeout() const {
  // @@protoc_insertion_point(field_get:pb.ConnectRequest.timeout)
  return _internal_timeout();
}
inline void ConnectRequest::_internal_set_timeout(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  timeout_ = value;
}
inline void ConnectRequest::set_timeout(int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:pb.ConnectRequest.timeout)
}

// -------------------------------------------------------------------

// StreamOpenRequest

// bytes peer = 1;
inline void StreamOpenRequest::clear_peer() {
  peer_.ClearToEmpty();
}
inline const std::string& StreamOpenRequest::peer() const {
  // @@protoc_insertion_point(field_get:pb.StreamOpenRequest.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamOpenRequest::set_peer(ArgT0&& arg0, ArgT... args) {
 
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StreamOpenRequest.peer)
}
inline std::string* StreamOpenRequest::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.StreamOpenRequest.peer)
  return _s;
}
inline const std::string& StreamOpenRequest::_internal_peer() const {
  return peer_.Get();
}
inline void StreamOpenRequest::_internal_set_peer(const std::string& value) {
  
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamOpenRequest::_internal_mutable_peer() {
  
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamOpenRequest::release_peer() {
  // @@protoc_insertion_point(field_release:pb.StreamOpenRequest.peer)
  return peer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamOpenRequest::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    
  } else {
    
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StreamOpenRequest.peer)
}

// repeated string proto = 2;
inline int StreamOpenRequest::_internal_proto_size() const {
  return proto_.size();
}
inline int StreamOpenRequest::proto_size() const {
  return _internal_proto_size();
}
inline void StreamOpenRequest::clear_proto() {
  proto_.Clear();
}
inline std::string* StreamOpenRequest::add_proto() {
  std::string* _s = _internal_add_proto();
  // @@protoc_insertion_point(field_add_mutable:pb.StreamOpenRequest.proto)
  return _s;
}
inline const std::string& StreamOpenRequest::_internal_proto(int index) const {
  return proto_.Get(index);
}
inline const std::string& StreamOpenRequest::proto(int index) const {
  // @@protoc_insertion_point(field_get:pb.StreamOpenRequest.proto)
  return _internal_proto(index);
}
inline std::string* StreamOpenRequest::mutable_proto(int index) {
  // @@protoc_insertion_point(field_mutable:pb.StreamOpenRequest.proto)
  return proto_.Mutable(index);
}
inline void StreamOpenRequest::set_proto(int index, const std::string& value) {
  proto_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::set_proto(int index, std::string&& value) {
  proto_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::set_proto(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proto_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::set_proto(int index, const char* value, size_t size) {
  proto_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StreamOpenRequest.proto)
}
inline std::string* StreamOpenRequest::_internal_add_proto() {
  return proto_.Add();
}
inline void StreamOpenRequest::add_proto(const std::string& value) {
  proto_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::add_proto(std::string&& value) {
  proto_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::add_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proto_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.StreamOpenRequest.proto)
}
inline void StreamOpenRequest::add_proto(const char* value, size_t size) {
  proto_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.StreamOpenRequest.proto)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOpenRequest::proto() const {
  // @@protoc_insertion_point(field_list:pb.StreamOpenRequest.proto)
  return proto_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOpenRequest::mutable_proto() {
  // @@protoc_insertion_point(field_mutable_list:pb.StreamOpenRequest.proto)
  return &proto_;
}

// optional int64 timeout = 3;
inline bool StreamOpenRequest::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamOpenRequest::has_timeout() const {
  return _internal_has_timeout();
}
inline void StreamOpenRequest::clear_timeout() {
  timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t StreamOpenRequest::_internal_timeout() const {
  return timeout_;
}
inline int64_t StreamOpenRequest::timeout() const {
  // @@protoc_insertion_point(field_get:pb.StreamOpenRequest.timeout)
  return _internal_timeout();
}
inline void StreamOpenRequest::_internal_set_timeout(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  timeout_ = value;
}
inline void StreamOpenRequest::set_timeout(int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:pb.StreamOpenRequest.timeout)
}

// -------------------------------------------------------------------

// StreamHandlerRequest

// bytes addr = 1;
inline void StreamHandlerRequest::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& StreamHandlerRequest::addr() const {
  // @@protoc_insertion_point(field_get:pb.StreamHandlerRequest.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamHandlerRequest::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StreamHandlerRequest.addr)
}
inline std::string* StreamHandlerRequest::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:pb.StreamHandlerRequest.addr)
  return _s;
}
inline const std::string& StreamHandlerRequest::_internal_addr() const {
  return addr_.Get();
}
inline void StreamHandlerRequest::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamHandlerRequest::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamHandlerRequest::release_addr() {
  // @@protoc_insertion_point(field_release:pb.StreamHandlerRequest.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamHandlerRequest::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StreamHandlerRequest.addr)
}

// repeated string proto = 2;
inline int StreamHandlerRequest::_internal_proto_size() const {
  return proto_.size();
}
inline int StreamHandlerRequest::proto_size() const {
  return _internal_proto_size();
}
inline void StreamHandlerRequest::clear_proto() {
  proto_.Clear();
}
inline std::string* StreamHandlerRequest::add_proto() {
  std::string* _s = _internal_add_proto();
  // @@protoc_insertion_point(field_add_mutable:pb.StreamHandlerRequest.proto)
  return _s;
}
inline const std::string& StreamHandlerRequest::_internal_proto(int index) const {
  return proto_.Get(index);
}
inline const std::string& StreamHandlerRequest::proto(int index) const {
  // @@protoc_insertion_point(field_get:pb.StreamHandlerRequest.proto)
  return _internal_proto(index);
}
inline std::string* StreamHandlerRequest::mutable_proto(int index) {
  // @@protoc_insertion_point(field_mutable:pb.StreamHandlerRequest.proto)
  return proto_.Mutable(index);
}
inline void StreamHandlerRequest::set_proto(int index, const std::string& value) {
  proto_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::set_proto(int index, std::string&& value) {
  proto_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::set_proto(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proto_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::set_proto(int index, const char* value, size_t size) {
  proto_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.StreamHandlerRequest.proto)
}
inline std::string* StreamHandlerRequest::_internal_add_proto() {
  return proto_.Add();
}
inline void StreamHandlerRequest::add_proto(const std::string& value) {
  proto_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::add_proto(std::string&& value) {
  proto_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::add_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proto_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.StreamHandlerRequest.proto)
}
inline void StreamHandlerRequest::add_proto(const char* value, size_t size) {
  proto_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.StreamHandlerRequest.proto)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamHandlerRequest::proto() const {
  // @@protoc_insertion_point(field_list:pb.StreamHandlerRequest.proto)
  return proto_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamHandlerRequest::mutable_proto() {
  // @@protoc_insertion_point(field_mutable_list:pb.StreamHandlerRequest.proto)
  return &proto_;
}

// -------------------------------------------------------------------

// ErrorResponse

// string msg = 1;
inline void ErrorResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ErrorResponse::msg() const {
  // @@protoc_insertion_point(field_get:pb.ErrorResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ErrorResponse.msg)
}
inline std::string* ErrorResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pb.ErrorResponse.msg)
  return _s;
}
inline const std::string& ErrorResponse::_internal_msg() const {
  return msg_.Get();
}
inline void ErrorResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_msg() {
  // @@protoc_insertion_point(field_release:pb.ErrorResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrorResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ErrorResponse.msg)
}

// -------------------------------------------------------------------

// StreamInfo

// bytes peer = 1;
inline void StreamInfo::clear_peer() {
  peer_.ClearToEmpty();
}
inline const std::string& StreamInfo::peer() const {
  // @@protoc_insertion_point(field_get:pb.StreamInfo.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_peer(ArgT0&& arg0, ArgT... args) {
 
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StreamInfo.peer)
}
inline std::string* StreamInfo::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.StreamInfo.peer)
  return _s;
}
inline const std::string& StreamInfo::_internal_peer() const {
  return peer_.Get();
}
inline void StreamInfo::_internal_set_peer(const std::string& value) {
  
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_peer() {
  
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamInfo::release_peer() {
  // @@protoc_insertion_point(field_release:pb.StreamInfo.peer)
  return peer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamInfo::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    
  } else {
    
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StreamInfo.peer)
}

// bytes addr = 2;
inline void StreamInfo::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& StreamInfo::addr() const {
  // @@protoc_insertion_point(field_get:pb.StreamInfo.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StreamInfo.addr)
}
inline std::string* StreamInfo::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:pb.StreamInfo.addr)
  return _s;
}
inline const std::string& StreamInfo::_internal_addr() const {
  return addr_.Get();
}
inline void StreamInfo::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamInfo::release_addr() {
  // @@protoc_insertion_point(field_release:pb.StreamInfo.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamInfo::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StreamInfo.addr)
}

// string proto = 3;
inline void StreamInfo::clear_proto() {
  proto_.ClearToEmpty();
}
inline const std::string& StreamInfo::proto() const {
  // @@protoc_insertion_point(field_get:pb.StreamInfo.proto)
  return _internal_proto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_proto(ArgT0&& arg0, ArgT... args) {
 
 proto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StreamInfo.proto)
}
inline std::string* StreamInfo::mutable_proto() {
  std::string* _s = _internal_mutable_proto();
  // @@protoc_insertion_point(field_mutable:pb.StreamInfo.proto)
  return _s;
}
inline const std::string& StreamInfo::_internal_proto() const {
  return proto_.Get();
}
inline void StreamInfo::_internal_set_proto(const std::string& value) {
  
  proto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_proto() {
  
  return proto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamInfo::release_proto() {
  // @@protoc_insertion_point(field_release:pb.StreamInfo.proto)
  return proto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamInfo::set_allocated_proto(std::string* proto) {
  if (proto != nullptr) {
    
  } else {
    
  }
  proto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StreamInfo.proto)
}

// -------------------------------------------------------------------

// DHTRequest

// optional .pb.DHTRequest.Type type = 1;
inline bool DHTRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DHTRequest::has_type() const {
  return _internal_has_type();
}
inline void DHTRequest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pb::DHTRequest_Type DHTRequest::_internal_type() const {
  return static_cast< ::pb::DHTRequest_Type >(type_);
}
inline ::pb::DHTRequest_Type DHTRequest::type() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.type)
  return _internal_type();
}
inline void DHTRequest::_internal_set_type(::pb::DHTRequest_Type value) {
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void DHTRequest::set_type(::pb::DHTRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.DHTRequest.type)
}

// optional bytes peer = 2;
inline bool DHTRequest::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DHTRequest::has_peer() const {
  return _internal_has_peer();
}
inline void DHTRequest::clear_peer() {
  peer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DHTRequest::peer() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DHTRequest::set_peer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DHTRequest.peer)
}
inline std::string* DHTRequest::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.DHTRequest.peer)
  return _s;
}
inline const std::string& DHTRequest::_internal_peer() const {
  return peer_.Get();
}
inline void DHTRequest::_internal_set_peer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DHTRequest::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DHTRequest::release_peer() {
  // @@protoc_insertion_point(field_release:pb.DHTRequest.peer)
  if (!_internal_has_peer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = peer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DHTRequest::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DHTRequest.peer)
}

// optional bytes cid = 3;
inline bool DHTRequest::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DHTRequest::has_cid() const {
  return _internal_has_cid();
}
inline void DHTRequest::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DHTRequest::cid() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DHTRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 cid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DHTRequest.cid)
}
inline std::string* DHTRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:pb.DHTRequest.cid)
  return _s;
}
inline const std::string& DHTRequest::_internal_cid() const {
  return cid_.Get();
}
inline void DHTRequest::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DHTRequest::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000002u;
  return cid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DHTRequest::release_cid() {
  // @@protoc_insertion_point(field_release:pb.DHTRequest.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = cid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DHTRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DHTRequest.cid)
}

// optional bytes key = 4;
inline bool DHTRequest::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DHTRequest::has_key() const {
  return _internal_has_key();
}
inline void DHTRequest::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DHTRequest::key() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DHTRequest::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DHTRequest.key)
}
inline std::string* DHTRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pb.DHTRequest.key)
  return _s;
}
inline const std::string& DHTRequest::_internal_key() const {
  return key_.Get();
}
inline void DHTRequest::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DHTRequest::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000004u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DHTRequest::release_key() {
  // @@protoc_insertion_point(field_release:pb.DHTRequest.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DHTRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DHTRequest.key)
}

// optional bytes value = 5;
inline bool DHTRequest::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DHTRequest::has_value() const {
  return _internal_has_value();
}
inline void DHTRequest::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DHTRequest::value() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DHTRequest::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DHTRequest.value)
}
inline std::string* DHTRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pb.DHTRequest.value)
  return _s;
}
inline const std::string& DHTRequest::_internal_value() const {
  return value_.Get();
}
inline void DHTRequest::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DHTRequest::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000008u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DHTRequest::release_value() {
  // @@protoc_insertion_point(field_release:pb.DHTRequest.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DHTRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DHTRequest.value)
}

// optional int32 count = 6;
inline bool DHTRequest::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DHTRequest::has_count() const {
  return _internal_has_count();
}
inline void DHTRequest::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t DHTRequest::_internal_count() const {
  return count_;
}
inline int32_t DHTRequest::count() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.count)
  return _internal_count();
}
inline void DHTRequest::_internal_set_count(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  count_ = value;
}
inline void DHTRequest::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:pb.DHTRequest.count)
}

// optional int64 timeout = 7;
inline bool DHTRequest::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DHTRequest::has_timeout() const {
  return _internal_has_timeout();
}
inline void DHTRequest::clear_timeout() {
  timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t DHTRequest::_internal_timeout() const {
  return timeout_;
}
inline int64_t DHTRequest::timeout() const {
  // @@protoc_insertion_point(field_get:pb.DHTRequest.timeout)
  return _internal_timeout();
}
inline void DHTRequest::_internal_set_timeout(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  timeout_ = value;
}
inline void DHTRequest::set_timeout(int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:pb.DHTRequest.timeout)
}

// -------------------------------------------------------------------

// DHTResponse

// optional .pb.DHTResponse.Type type = 1;
inline bool DHTResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DHTResponse::has_type() const {
  return _internal_has_type();
}
inline void DHTResponse::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pb::DHTResponse_Type DHTResponse::_internal_type() const {
  return static_cast< ::pb::DHTResponse_Type >(type_);
}
inline ::pb::DHTResponse_Type DHTResponse::type() const {
  // @@protoc_insertion_point(field_get:pb.DHTResponse.type)
  return _internal_type();
}
inline void DHTResponse::_internal_set_type(::pb::DHTResponse_Type value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DHTResponse::set_type(::pb::DHTResponse_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.DHTResponse.type)
}

// optional .pb.PeerInfo peer = 2;
inline bool DHTResponse::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || peer_ != nullptr);
  return value;
}
inline bool DHTResponse::has_peer() const {
  return _internal_has_peer();
}
inline void DHTResponse::clear_peer() {
  if (peer_ != nullptr) peer_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pb::PeerInfo& DHTResponse::_internal_peer() const {
  const ::pb::PeerInfo* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PeerInfo&>(
      ::pb::_PeerInfo_default_instance_);
}
inline const ::pb::PeerInfo& DHTResponse::peer() const {
  // @@protoc_insertion_point(field_get:pb.DHTResponse.peer)
  return _internal_peer();
}
inline void DHTResponse::unsafe_arena_set_allocated_peer(
    ::pb::PeerInfo* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.DHTResponse.peer)
}
inline ::pb::PeerInfo* DHTResponse::release_peer() {
  _has_bits_[0] &= ~0x00000002u;
  ::pb::PeerInfo* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PeerInfo* DHTResponse::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:pb.DHTResponse.peer)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::PeerInfo* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::pb::PeerInfo* DHTResponse::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000002u;
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PeerInfo>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::pb::PeerInfo* DHTResponse::mutable_peer() {
  ::pb::PeerInfo* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.DHTResponse.peer)
  return _msg;
}
inline void DHTResponse::set_allocated_peer(::pb::PeerInfo* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peer_;
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PeerInfo>::GetOwningArena(peer);
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:pb.DHTResponse.peer)
}

// optional bytes value = 3;
inline bool DHTResponse::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DHTResponse::has_value() const {
  return _internal_has_value();
}
inline void DHTResponse::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DHTResponse::value() const {
  // @@protoc_insertion_point(field_get:pb.DHTResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DHTResponse::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DHTResponse.value)
}
inline std::string* DHTResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pb.DHTResponse.value)
  return _s;
}
inline const std::string& DHTResponse::_internal_value() const {
  return value_.Get();
}
inline void DHTResponse::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DHTResponse::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DHTResponse::release_value() {
  // @@protoc_insertion_point(field_release:pb.DHTResponse.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DHTResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DHTResponse.value)
}

// -------------------------------------------------------------------

// PeerInfo

// bytes id = 1;
inline void PeerInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& PeerInfo::id() const {
  // @@protoc_insertion_point(field_get:pb.PeerInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PeerInfo.id)
}
inline std::string* PeerInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:pb.PeerInfo.id)
  return _s;
}
inline const std::string& PeerInfo::_internal_id() const {
  return id_.Get();
}
inline void PeerInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerInfo::release_id() {
  // @@protoc_insertion_point(field_release:pb.PeerInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PeerInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PeerInfo.id)
}

// repeated bytes addrs = 2;
inline int PeerInfo::_internal_addrs_size() const {
  return addrs_.size();
}
inline int PeerInfo::addrs_size() const {
  return _internal_addrs_size();
}
inline void PeerInfo::clear_addrs() {
  addrs_.Clear();
}
inline std::string* PeerInfo::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:pb.PeerInfo.addrs)
  return _s;
}
inline const std::string& PeerInfo::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& PeerInfo::addrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.PeerInfo.addrs)
  return _internal_addrs(index);
}
inline std::string* PeerInfo::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PeerInfo.addrs)
  return addrs_.Mutable(index);
}
inline void PeerInfo::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PeerInfo.addrs)
}
inline void PeerInfo::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PeerInfo.addrs)
}
inline void PeerInfo::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PeerInfo.addrs)
}
inline void PeerInfo::set_addrs(int index, const void* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PeerInfo.addrs)
}
inline std::string* PeerInfo::_internal_add_addrs() {
  return addrs_.Add();
}
inline void PeerInfo::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PeerInfo.addrs)
}
inline void PeerInfo::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PeerInfo.addrs)
}
inline void PeerInfo::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PeerInfo.addrs)
}
inline void PeerInfo::add_addrs(const void* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PeerInfo.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeerInfo::addrs() const {
  // @@protoc_insertion_point(field_list:pb.PeerInfo.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeerInfo::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.PeerInfo.addrs)
  return &addrs_;
}

// -------------------------------------------------------------------

// ConnManagerRequest

// optional .pb.ConnManagerRequest.Type type = 1;
inline bool ConnManagerRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnManagerRequest::has_type() const {
  return _internal_has_type();
}
inline void ConnManagerRequest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pb::ConnManagerRequest_Type ConnManagerRequest::_internal_type() const {
  return static_cast< ::pb::ConnManagerRequest_Type >(type_);
}
inline ::pb::ConnManagerRequest_Type ConnManagerRequest::type() const {
  // @@protoc_insertion_point(field_get:pb.ConnManagerRequest.type)
  return _internal_type();
}
inline void ConnManagerRequest::_internal_set_type(::pb::ConnManagerRequest_Type value) {
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void ConnManagerRequest::set_type(::pb::ConnManagerRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.ConnManagerRequest.type)
}

// optional bytes peer = 2;
inline bool ConnManagerRequest::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnManagerRequest::has_peer() const {
  return _internal_has_peer();
}
inline void ConnManagerRequest::clear_peer() {
  peer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnManagerRequest::peer() const {
  // @@protoc_insertion_point(field_get:pb.ConnManagerRequest.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnManagerRequest::set_peer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ConnManagerRequest.peer)
}
inline std::string* ConnManagerRequest::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.ConnManagerRequest.peer)
  return _s;
}
inline const std::string& ConnManagerRequest::_internal_peer() const {
  return peer_.Get();
}
inline void ConnManagerRequest::_internal_set_peer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnManagerRequest::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnManagerRequest::release_peer() {
  // @@protoc_insertion_point(field_release:pb.ConnManagerRequest.peer)
  if (!_internal_has_peer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = peer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnManagerRequest::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ConnManagerRequest.peer)
}

// optional string tag = 3;
inline bool ConnManagerRequest::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnManagerRequest::has_tag() const {
  return _internal_has_tag();
}
inline void ConnManagerRequest::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnManagerRequest::tag() const {
  // @@protoc_insertion_point(field_get:pb.ConnManagerRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnManagerRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ConnManagerRequest.tag)
}
inline std::string* ConnManagerRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:pb.ConnManagerRequest.tag)
  return _s;
}
inline const std::string& ConnManagerRequest::_internal_tag() const {
  return tag_.Get();
}
inline void ConnManagerRequest::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnManagerRequest::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnManagerRequest::release_tag() {
  // @@protoc_insertion_point(field_release:pb.ConnManagerRequest.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnManagerRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ConnManagerRequest.tag)
}

// optional int64 weight = 4;
inline bool ConnManagerRequest::_internal_has_weight() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnManagerRequest::has_weight() const {
  return _internal_has_weight();
}
inline void ConnManagerRequest::clear_weight() {
  weight_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ConnManagerRequest::_internal_weight() const {
  return weight_;
}
inline int64_t ConnManagerRequest::weight() const {
  // @@protoc_insertion_point(field_get:pb.ConnManagerRequest.weight)
  return _internal_weight();
}
inline void ConnManagerRequest::_internal_set_weight(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  weight_ = value;
}
inline void ConnManagerRequest::set_weight(int64_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:pb.ConnManagerRequest.weight)
}

// -------------------------------------------------------------------

// DisconnectRequest

// bytes peer = 1;
inline void DisconnectRequest::clear_peer() {
  peer_.ClearToEmpty();
}
inline const std::string& DisconnectRequest::peer() const {
  // @@protoc_insertion_point(field_get:pb.DisconnectRequest.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisconnectRequest::set_peer(ArgT0&& arg0, ArgT... args) {
 
 peer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DisconnectRequest.peer)
}
inline std::string* DisconnectRequest::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.DisconnectRequest.peer)
  return _s;
}
inline const std::string& DisconnectRequest::_internal_peer() const {
  return peer_.Get();
}
inline void DisconnectRequest::_internal_set_peer(const std::string& value) {
  
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DisconnectRequest::_internal_mutable_peer() {
  
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DisconnectRequest::release_peer() {
  // @@protoc_insertion_point(field_release:pb.DisconnectRequest.peer)
  return peer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DisconnectRequest::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    
  } else {
    
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.DisconnectRequest.peer)
}

// -------------------------------------------------------------------

// PSRequest

// optional .pb.PSRequest.Type type = 1;
inline bool PSRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PSRequest::has_type() const {
  return _internal_has_type();
}
inline void PSRequest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pb::PSRequest_Type PSRequest::_internal_type() const {
  return static_cast< ::pb::PSRequest_Type >(type_);
}
inline ::pb::PSRequest_Type PSRequest::type() const {
  // @@protoc_insertion_point(field_get:pb.PSRequest.type)
  return _internal_type();
}
inline void PSRequest::_internal_set_type(::pb::PSRequest_Type value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void PSRequest::set_type(::pb::PSRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.PSRequest.type)
}

// optional string topic = 2;
inline bool PSRequest::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PSRequest::has_topic() const {
  return _internal_has_topic();
}
inline void PSRequest::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PSRequest::topic() const {
  // @@protoc_insertion_point(field_get:pb.PSRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSRequest.topic)
}
inline std::string* PSRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pb.PSRequest.topic)
  return _s;
}
inline const std::string& PSRequest::_internal_topic() const {
  return topic_.Get();
}
inline void PSRequest::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSRequest::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSRequest::release_topic() {
  // @@protoc_insertion_point(field_release:pb.PSRequest.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSRequest.topic)
}

// optional bytes data = 3;
inline bool PSRequest::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PSRequest::has_data() const {
  return _internal_has_data();
}
inline void PSRequest::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PSRequest::data() const {
  // @@protoc_insertion_point(field_get:pb.PSRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSRequest::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSRequest.data)
}
inline std::string* PSRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:pb.PSRequest.data)
  return _s;
}
inline const std::string& PSRequest::_internal_data() const {
  return data_.Get();
}
inline void PSRequest::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSRequest::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSRequest::release_data() {
  // @@protoc_insertion_point(field_release:pb.PSRequest.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSRequest.data)
}

// -------------------------------------------------------------------

// PSMessage

// optional bytes from = 1;
inline bool PSMessage::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PSMessage::has_from() const {
  return _internal_has_from();
}
inline void PSMessage::clear_from() {
  from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PSMessage::from() const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSMessage::set_from(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 from_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSMessage.from)
}
inline std::string* PSMessage::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.from)
  return _s;
}
inline const std::string& PSMessage::_internal_from() const {
  return from_.Get();
}
inline void PSMessage::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSMessage::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000001u;
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSMessage::release_from() {
  // @@protoc_insertion_point(field_release:pb.PSMessage.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSMessage::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSMessage.from)
}

// optional bytes data = 2;
inline bool PSMessage::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PSMessage::has_data() const {
  return _internal_has_data();
}
inline void PSMessage::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PSMessage::data() const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSMessage::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSMessage.data)
}
inline std::string* PSMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.data)
  return _s;
}
inline const std::string& PSMessage::_internal_data() const {
  return data_.Get();
}
inline void PSMessage::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSMessage::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSMessage::release_data() {
  // @@protoc_insertion_point(field_release:pb.PSMessage.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSMessage.data)
}

// optional bytes seqno = 3;
inline bool PSMessage::_internal_has_seqno() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PSMessage::has_seqno() const {
  return _internal_has_seqno();
}
inline void PSMessage::clear_seqno() {
  seqno_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PSMessage::seqno() const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.seqno)
  return _internal_seqno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSMessage::set_seqno(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 seqno_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSMessage.seqno)
}
inline std::string* PSMessage::mutable_seqno() {
  std::string* _s = _internal_mutable_seqno();
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.seqno)
  return _s;
}
inline const std::string& PSMessage::_internal_seqno() const {
  return seqno_.Get();
}
inline void PSMessage::_internal_set_seqno(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  seqno_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSMessage::_internal_mutable_seqno() {
  _has_bits_[0] |= 0x00000004u;
  return seqno_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSMessage::release_seqno() {
  // @@protoc_insertion_point(field_release:pb.PSMessage.seqno)
  if (!_internal_has_seqno()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = seqno_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seqno_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    seqno_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSMessage::set_allocated_seqno(std::string* seqno) {
  if (seqno != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  seqno_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), seqno,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seqno_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    seqno_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSMessage.seqno)
}

// repeated string topicIDs = 4;
inline int PSMessage::_internal_topicids_size() const {
  return topicids_.size();
}
inline int PSMessage::topicids_size() const {
  return _internal_topicids_size();
}
inline void PSMessage::clear_topicids() {
  topicids_.Clear();
}
inline std::string* PSMessage::add_topicids() {
  std::string* _s = _internal_add_topicids();
  // @@protoc_insertion_point(field_add_mutable:pb.PSMessage.topicIDs)
  return _s;
}
inline const std::string& PSMessage::_internal_topicids(int index) const {
  return topicids_.Get(index);
}
inline const std::string& PSMessage::topicids(int index) const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.topicIDs)
  return _internal_topicids(index);
}
inline std::string* PSMessage::mutable_topicids(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.topicIDs)
  return topicids_.Mutable(index);
}
inline void PSMessage::set_topicids(int index, const std::string& value) {
  topicids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PSMessage.topicIDs)
}
inline void PSMessage::set_topicids(int index, std::string&& value) {
  topicids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PSMessage.topicIDs)
}
inline void PSMessage::set_topicids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topicids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PSMessage.topicIDs)
}
inline void PSMessage::set_topicids(int index, const char* value, size_t size) {
  topicids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PSMessage.topicIDs)
}
inline std::string* PSMessage::_internal_add_topicids() {
  return topicids_.Add();
}
inline void PSMessage::add_topicids(const std::string& value) {
  topicids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PSMessage.topicIDs)
}
inline void PSMessage::add_topicids(std::string&& value) {
  topicids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PSMessage.topicIDs)
}
inline void PSMessage::add_topicids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topicids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PSMessage.topicIDs)
}
inline void PSMessage::add_topicids(const char* value, size_t size) {
  topicids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PSMessage.topicIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PSMessage::topicids() const {
  // @@protoc_insertion_point(field_list:pb.PSMessage.topicIDs)
  return topicids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PSMessage::mutable_topicids() {
  // @@protoc_insertion_point(field_mutable_list:pb.PSMessage.topicIDs)
  return &topicids_;
}

// optional bytes signature = 5;
inline bool PSMessage::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PSMessage::has_signature() const {
  return _internal_has_signature();
}
inline void PSMessage::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PSMessage::signature() const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSMessage.signature)
}
inline std::string* PSMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.signature)
  return _s;
}
inline const std::string& PSMessage::_internal_signature() const {
  return signature_.Get();
}
inline void PSMessage::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSMessage::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000008u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSMessage::release_signature() {
  // @@protoc_insertion_point(field_release:pb.PSMessage.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSMessage.signature)
}

// optional bytes key = 6;
inline bool PSMessage::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PSMessage::has_key() const {
  return _internal_has_key();
}
inline void PSMessage::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PSMessage::key() const {
  // @@protoc_insertion_point(field_get:pb.PSMessage.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PSMessage::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PSMessage.key)
}
inline std::string* PSMessage::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pb.PSMessage.key)
  return _s;
}
inline const std::string& PSMessage::_internal_key() const {
  return key_.Get();
}
inline void PSMessage::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PSMessage::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000010u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PSMessage::release_key() {
  // @@protoc_insertion_point(field_release:pb.PSMessage.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PSMessage::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PSMessage.key)
}

// -------------------------------------------------------------------

// PSResponse

// repeated string topics = 1;
inline int PSResponse::_internal_topics_size() const {
  return topics_.size();
}
inline int PSResponse::topics_size() const {
  return _internal_topics_size();
}
inline void PSResponse::clear_topics() {
  topics_.Clear();
}
inline std::string* PSResponse::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:pb.PSResponse.topics)
  return _s;
}
inline const std::string& PSResponse::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const std::string& PSResponse::topics(int index) const {
  // @@protoc_insertion_point(field_get:pb.PSResponse.topics)
  return _internal_topics(index);
}
inline std::string* PSResponse::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PSResponse.topics)
  return topics_.Mutable(index);
}
inline void PSResponse::set_topics(int index, const std::string& value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PSResponse.topics)
}
inline void PSResponse::set_topics(int index, std::string&& value) {
  topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PSResponse.topics)
}
inline void PSResponse::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PSResponse.topics)
}
inline void PSResponse::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PSResponse.topics)
}
inline std::string* PSResponse::_internal_add_topics() {
  return topics_.Add();
}
inline void PSResponse::add_topics(const std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PSResponse.topics)
}
inline void PSResponse::add_topics(std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PSResponse.topics)
}
inline void PSResponse::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PSResponse.topics)
}
inline void PSResponse::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PSResponse.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PSResponse::topics() const {
  // @@protoc_insertion_point(field_list:pb.PSResponse.topics)
  return topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PSResponse::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:pb.PSResponse.topics)
  return &topics_;
}

// repeated bytes peerIDs = 2;
inline int PSResponse::_internal_peerids_size() const {
  return peerids_.size();
}
inline int PSResponse::peerids_size() const {
  return _internal_peerids_size();
}
inline void PSResponse::clear_peerids() {
  peerids_.Clear();
}
inline std::string* PSResponse::add_peerids() {
  std::string* _s = _internal_add_peerids();
  // @@protoc_insertion_point(field_add_mutable:pb.PSResponse.peerIDs)
  return _s;
}
inline const std::string& PSResponse::_internal_peerids(int index) const {
  return peerids_.Get(index);
}
inline const std::string& PSResponse::peerids(int index) const {
  // @@protoc_insertion_point(field_get:pb.PSResponse.peerIDs)
  return _internal_peerids(index);
}
inline std::string* PSResponse::mutable_peerids(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PSResponse.peerIDs)
  return peerids_.Mutable(index);
}
inline void PSResponse::set_peerids(int index, const std::string& value) {
  peerids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PSResponse.peerIDs)
}
inline void PSResponse::set_peerids(int index, std::string&& value) {
  peerids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PSResponse.peerIDs)
}
inline void PSResponse::set_peerids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peerids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PSResponse.peerIDs)
}
inline void PSResponse::set_peerids(int index, const void* value, size_t size) {
  peerids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PSResponse.peerIDs)
}
inline std::string* PSResponse::_internal_add_peerids() {
  return peerids_.Add();
}
inline void PSResponse::add_peerids(const std::string& value) {
  peerids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PSResponse.peerIDs)
}
inline void PSResponse::add_peerids(std::string&& value) {
  peerids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PSResponse.peerIDs)
}
inline void PSResponse::add_peerids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peerids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PSResponse.peerIDs)
}
inline void PSResponse::add_peerids(const void* value, size_t size) {
  peerids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PSResponse.peerIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PSResponse::peerids() const {
  // @@protoc_insertion_point(field_list:pb.PSResponse.peerIDs)
  return peerids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PSResponse::mutable_peerids() {
  // @@protoc_insertion_point(field_mutable_list:pb.PSResponse.peerIDs)
  return &peerids_;
}

// -------------------------------------------------------------------

// PeerstoreRequest

// optional .pb.PeerstoreRequest.Type type = 1;
inline bool PeerstoreRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PeerstoreRequest::has_type() const {
  return _internal_has_type();
}
inline void PeerstoreRequest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::pb::PeerstoreRequest_Type PeerstoreRequest::_internal_type() const {
  return static_cast< ::pb::PeerstoreRequest_Type >(type_);
}
inline ::pb::PeerstoreRequest_Type PeerstoreRequest::type() const {
  // @@protoc_insertion_point(field_get:pb.PeerstoreRequest.type)
  return _internal_type();
}
inline void PeerstoreRequest::_internal_set_type(::pb::PeerstoreRequest_Type value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void PeerstoreRequest::set_type(::pb::PeerstoreRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.PeerstoreRequest.type)
}

// optional bytes id = 2;
inline bool PeerstoreRequest::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PeerstoreRequest::has_id() const {
  return _internal_has_id();
}
inline void PeerstoreRequest::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerstoreRequest::id() const {
  // @@protoc_insertion_point(field_get:pb.PeerstoreRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerstoreRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PeerstoreRequest.id)
}
inline std::string* PeerstoreRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:pb.PeerstoreRequest.id)
  return _s;
}
inline const std::string& PeerstoreRequest::_internal_id() const {
  return id_.Get();
}
inline void PeerstoreRequest::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerstoreRequest::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerstoreRequest::release_id() {
  // @@protoc_insertion_point(field_release:pb.PeerstoreRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PeerstoreRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PeerstoreRequest.id)
}

// repeated string protos = 3;
inline int PeerstoreRequest::_internal_protos_size() const {
  return protos_.size();
}
inline int PeerstoreRequest::protos_size() const {
  return _internal_protos_size();
}
inline void PeerstoreRequest::clear_protos() {
  protos_.Clear();
}
inline std::string* PeerstoreRequest::add_protos() {
  std::string* _s = _internal_add_protos();
  // @@protoc_insertion_point(field_add_mutable:pb.PeerstoreRequest.protos)
  return _s;
}
inline const std::string& PeerstoreRequest::_internal_protos(int index) const {
  return protos_.Get(index);
}
inline const std::string& PeerstoreRequest::protos(int index) const {
  // @@protoc_insertion_point(field_get:pb.PeerstoreRequest.protos)
  return _internal_protos(index);
}
inline std::string* PeerstoreRequest::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PeerstoreRequest.protos)
  return protos_.Mutable(index);
}
inline void PeerstoreRequest::set_protos(int index, const std::string& value) {
  protos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::set_protos(int index, std::string&& value) {
  protos_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::set_protos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  protos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::set_protos(int index, const char* value, size_t size) {
  protos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PeerstoreRequest.protos)
}
inline std::string* PeerstoreRequest::_internal_add_protos() {
  return protos_.Add();
}
inline void PeerstoreRequest::add_protos(const std::string& value) {
  protos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::add_protos(std::string&& value) {
  protos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::add_protos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  protos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PeerstoreRequest.protos)
}
inline void PeerstoreRequest::add_protos(const char* value, size_t size) {
  protos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PeerstoreRequest.protos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeerstoreRequest::protos() const {
  // @@protoc_insertion_point(field_list:pb.PeerstoreRequest.protos)
  return protos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeerstoreRequest::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:pb.PeerstoreRequest.protos)
  return &protos_;
}

// -------------------------------------------------------------------

// PeerstoreResponse

// optional .pb.PeerInfo peer = 1;
inline bool PeerstoreResponse::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || peer_ != nullptr);
  return value;
}
inline bool PeerstoreResponse::has_peer() const {
  return _internal_has_peer();
}
inline void PeerstoreResponse::clear_peer() {
  if (peer_ != nullptr) peer_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pb::PeerInfo& PeerstoreResponse::_internal_peer() const {
  const ::pb::PeerInfo* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PeerInfo&>(
      ::pb::_PeerInfo_default_instance_);
}
inline const ::pb::PeerInfo& PeerstoreResponse::peer() const {
  // @@protoc_insertion_point(field_get:pb.PeerstoreResponse.peer)
  return _internal_peer();
}
inline void PeerstoreResponse::unsafe_arena_set_allocated_peer(
    ::pb::PeerInfo* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PeerstoreResponse.peer)
}
inline ::pb::PeerInfo* PeerstoreResponse::release_peer() {
  _has_bits_[0] &= ~0x00000001u;
  ::pb::PeerInfo* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::PeerInfo* PeerstoreResponse::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:pb.PeerstoreResponse.peer)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::PeerInfo* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::pb::PeerInfo* PeerstoreResponse::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PeerInfo>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::pb::PeerInfo* PeerstoreResponse::mutable_peer() {
  ::pb::PeerInfo* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:pb.PeerstoreResponse.peer)
  return _msg;
}
inline void PeerstoreResponse::set_allocated_peer(::pb::PeerInfo* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peer_;
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::PeerInfo>::GetOwningArena(peer);
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:pb.PeerstoreResponse.peer)
}

// repeated string protos = 2;
inline int PeerstoreResponse::_internal_protos_size() const {
  return protos_.size();
}
inline int PeerstoreResponse::protos_size() const {
  return _internal_protos_size();
}
inline void PeerstoreResponse::clear_protos() {
  protos_.Clear();
}
inline std::string* PeerstoreResponse::add_protos() {
  std::string* _s = _internal_add_protos();
  // @@protoc_insertion_point(field_add_mutable:pb.PeerstoreResponse.protos)
  return _s;
}
inline const std::string& PeerstoreResponse::_internal_protos(int index) const {
  return protos_.Get(index);
}
inline const std::string& PeerstoreResponse::protos(int index) const {
  // @@protoc_insertion_point(field_get:pb.PeerstoreResponse.protos)
  return _internal_protos(index);
}
inline std::string* PeerstoreResponse::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PeerstoreResponse.protos)
  return protos_.Mutable(index);
}
inline void PeerstoreResponse::set_protos(int index, const std::string& value) {
  protos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::set_protos(int index, std::string&& value) {
  protos_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::set_protos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  protos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::set_protos(int index, const char* value, size_t size) {
  protos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.PeerstoreResponse.protos)
}
inline std::string* PeerstoreResponse::_internal_add_protos() {
  return protos_.Add();
}
inline void PeerstoreResponse::add_protos(const std::string& value) {
  protos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::add_protos(std::string&& value) {
  protos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::add_protos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  protos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.PeerstoreResponse.protos)
}
inline void PeerstoreResponse::add_protos(const char* value, size_t size) {
  protos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.PeerstoreResponse.protos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeerstoreResponse::protos() const {
  // @@protoc_insertion_point(field_list:pb.PeerstoreResponse.protos)
  return protos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeerstoreResponse::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:pb.PeerstoreResponse.protos)
  return &protos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::Request_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Request_Type>() {
  return ::pb::Request_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::Response_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Response_Type>() {
  return ::pb::Response_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::DHTRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::DHTRequest_Type>() {
  return ::pb::DHTRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::DHTResponse_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::DHTResponse_Type>() {
  return ::pb::DHTResponse_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::ConnManagerRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ConnManagerRequest_Type>() {
  return ::pb::ConnManagerRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::PSRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::PSRequest_Type>() {
  return ::pb::PSRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::PeerstoreRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::PeerstoreRequest_Type>() {
  return ::pb::PeerstoreRequest_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_interop_2eproto
